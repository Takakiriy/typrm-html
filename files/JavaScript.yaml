#keyword: JavaScript.yaml, js, TypeScript  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg
設定: #settings:
    __Proxy__: http://host:port
    __Project__: try_node_js
記号: #ref: https://book.yyts.org/symbols-and-keywords
    =>: #// アロー関数, 無名の関数
    (&&), (||):  #search: JavaScript && ||
    (?):  #search: TypeScript optional argument
    ...:  #// スプレッド構文  #search: JavaScript spread operator
    <>, </>: #search: React.Fragment
    {' '}: #// 空白のコード JSX(?)
JavaScript TypeScirpt を試す, デバッグ方法:
    プロジェクト: #search: Node.js projects
    TypeScript Playground: #ref: https://www.typescriptlang.org/play
    MDN で試す: #// https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math/max  #keyword: MDN
        動作する JavaScript エンジン: ブラウザーの JavaScript のバージョンが動きます。
            MDN の各ページの下側に書いてあるブラウザーの互換性に注意してください
        import, require を使う場合:
            typrm の開発環境を開きます:  #ref: ${GitHub}/typrm
            typrm_test.ts の先頭: |  #ref: ${GitHub}/typrm/src/typrm_test.ts
                import * as path from 'path';
                    :
                const d = path.basename( '/path/to' );    // お試しコード
            ブレークポイントを張り、d をウォッチします:
    デバッガー:
        - ブレークした後に非同期処理が入るときは、print を使い、デバッグ対象を再起動してください。
            非同期処理を実行したら、ウォッチしている変数の値やブレークする順番が正しくなくなります。
        - dd, watchPrint, countThrough
        - Jest で例外がキャッチされなかったときは、コールスタックが表示されます
    Jest の test.each の中の 1行だけ実行します:  #keyword: test.only  #snippet-depth: 2
        サンプル:
            if (caseName !== '____') {return;}  // || subCase !== '____'
                chdirInProject('src')
                __TestCode__
            expect('test code').toBe('deleted skip code.');
        実行する test.each を test.only.each に置き換えます:
        テスト関数の最初に実行しない行についてスキップするコードを書きます:
    未定義のテストがあることをスキップで記録します:  #keyword: test.skip
        test.skip('__TestName__',()=>{});
    tsconfig.json:  #keyword:
        サンプル:
            ES2015 Node.js:  #// updated 2021-10-30  #ref: ${GitHub}/Trials/try_TypeScript_Node_js/tsconfig.json
                package.json: |
                    {
                        "name": "try_typescript_nodfe_js",
                        "version": "0.1.1",
                        "description": "",
                        "scripts": {
                            "setup": "npm ci",
                            "clean": "powershell rm -r -fo node_modules"
                        },
                        "author": "",
                        "license": "ISC",
                        "private": false,
                        "dependencies": {
                            "globby": "^12.0.2"
                        },
                        "type": "module",
                        "devDependencies": {
                            "@types/jest": "^26.0.24",
                            "@types/node": "^13.13.52",
                            "jest": "^27.3.1",
                            "ts-jest": "^27.0.7",
                            "ts-node": "^9.1.1",
                            "typescript": "^4.4.4"
                        },
                        "jest": {
                            "roots": [
                                "<rootDir>/src"
                            ],
                            "testMatch": [
                                "**/__tests__/**/*.+(ts|tsx|js)",
                                "**/?(*.)+(spec|test).+(ts|tsx|js)"
                            ],
                            "transform": {
                                "^.+\\.(ts|tsx)$": "ts-jest"
                            }
                        }
                    }
                tsconfig.js: |
                    {
                        "compilerOptions": {
                            "declaration": true,
                            "strict": true,
                            "target": "es2015",
                            "module": "es2015",
                            "lib": [ "es2015" ],
                            "moduleResolution": "node",
                            "experimentalDecorators": true,
                            "inlineSourceMap": true,
                            "inlineSources": true,
                            "outDir": "build"
                        }
                    }
            古い設定:
                package.json: |
                    {
                        "name": "try_typescript_nodfe_js",
                        "version": "0.1.1",
                        "description": "",
                        "scripts": {
                            "setup": "npm ci",
                            "clean": "powershell rm -r -fo node_modules"
                        },
                        "author": "",
                        "license": "ISC",
                        "private": false,
                        "dependencies": {
                        },
                        "devDependencies": {
                            "@types/jest": "^26.0.16",
                            "@types/node": "^13.13.4",
                            "jest": "^26.6.3",
                            "ts-jest": "^26.4.4",
                            "ts-node": "^9.1.1",
                            "typescript": "^4.1.2"
                        },
                        "jest": {
                            "roots": [
                                "<rootDir>/src"
                            ],
                            "testMatch": [
                                "**/__tests__/**/*.+(ts|tsx|js)",
                                "**/?(*.)+(spec|test).+(ts|tsx|js)"
                            ],
                            "transform": {
                                "^.+\\.(ts|tsx)$": "ts-jest"
                            }
                        }
                    }
                tsconfig.js: |
                    {
                        "compilerOptions": {
                            "declaration": true,
                            "strict": true,
                            "lib": [ "es2015", "dom" ],
                            "inlineSourceMap": true,
                            "inlineSources": true,
                            "outDir": "build"
                        }
                    }
        tsconfig.json の各種設定の必要性:
            experimentalDecorators:
                tsconfig.json: |
                    {
                        "compilerOptions": {
                            "experimentalDecorators": true,
                設定しないと発生するエラー:
                    Experimental support for decorators is a feature that is subject to change in a future release.
                    Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning.
                エラーが発生するケース: |
                    デコレーター（@）を使うとき。
                    example.ts:
                        @immutable
                        class Sample {
            moduleResolution:
                tsconfig.json: |
                    {
                        "compilerOptions": {
                            "moduleResolution": "node",
                設定しないと発生するエラー:
                    Cannot find module '@babel/parser'. Did you mean to set the 'moduleResolution' option to 'node', or to add aliases to the 'paths' option?
                    https://qiita.com/macotok/items/3fb60315da9206f9805c
                エラーが発生するケース:
                    tsconfig.json: |
                        {
                            "compilerOptions": {
                                "target": "ES2015",
            type module:
                package.json: |
                    {
                        "type": "module",
                設定しないと発生するエラー: |
                    Uncaught TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension ".ts" for /Users/totadashi/Desktop/try_TypeScript_Node_js/src/app_test.ts
                    https://stackoverflow.com/questions/62096269/cant-run-my-node-js-typescript-project-typeerror-err-unknown-file-extension
                エラーが発生するケース:
                    tsconfig.json: |
                        {
                            "compilerOptions": {
                                "target": "ES2015",
        Node.js のバージョンによる設定:
            #ref: https://qiita.com/suin/items/32f76c9b88b8daa286c4
        その他の設定:
            baseUrl: #keyword: tsconfig.json baseUrl  #// インポートするときのルートにするパス
                公式: #ref: https://www.typescriptlang.org/docs/handbook/module-resolution.html#base-url
                サンプル: #keyword: baseUrl, from, src/lib
                    __Project__/src/example.ts: |
                        import {foo} from 'src/lib';
                        foo();
                    __Project__/src/lib.ts: |
                        export function  foo() {
                            console.log('foo');
                        }
                    tsconfig.json: |
                        {
                            "compilerOptions": {
                                "baseUrl": "."
                import from 値:
                    baseUrl からの相対パス（絶対パス相当）を指定する場合:
                        - import {foo} from 'src/lib';  #// "." 以外から始めます。baseUrl の設定が必須です
                    .ts ファイルがあるフォルダーからの相対パスを指定する場合:
                        - import {foo} from './lib';  #// "." から始めます
                        - import {foo} from '../lib';
                baseUrl の値: tsconfig.json ファイルがあるフォルダーからの相対パス
            paths: #keyword: tsconfig.json paths,  TypeScript import @  #// インポートするときのパスのベースを変更します
                公式: #ref: https://www.typescriptlang.org/tsconfig/#paths
                注意: baseUrl の設定は必須です。絶対パス相当を指定するだけなら baseUrl だけでできます。
                サンプル: #keyword: paths, baseUrl, from, @src, lib
                    __Project__/src/example.ts: |
                        import {foo} from '@src/lib';
                        foo();
                    __Project__/src/lib.ts: |
                        export function  foo() {
                            console.log('foo');
                        }
                    tsconfig.json: |
                        {
                            "compilerOptions": {
                                "baseUrl": ".",
                                "paths": {
                                    "@src/*": ["src/*"]  // @src を __Project__/src に対応させます
                                }
                (@): (@src) のような @ は必須ではありませんが、paths 属性で置き換えられることが分かりやすくなります
                参考: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#tsconfig_json_paths
バージョン:
    概要: #ref: https://www.tohoho-web.com/js/what.htm
    ES2020: ECMAScript 2020, ES11
    ES2019: ECMAScript 2019, ES10
    ES2018: ECMAScript 2018, ES9
    ES2017: ECMAScript 2017, ES8
    ES2016: ECMAScript 2016, ES7
    ES2015: ECMAScript 2015, ES6
    ES5.1: ECMAScript 5.1th Edition
    ES5: ECMAScript 5th Edition
文法:
    制御構文: #glossary: js
        if:
            値のみの条件式 if(___):  #// 例: if (var), if (undefined)  #keyword: JavaScript if value only
                偽と判定される値:
                    if (false)
                    if (0)
                    if ('')
                    if (undefined)
                    if (null)
                    if (NaN)
                真と判定される値:
                    if (true)
                    if (1)
                    if ('a')
                    if (' ')
                    if ({a:1})
                    if ({})
            (&&), (||):  #keyword: JavaScript && ||
                注意: 偽は nullなども含みます
                __A__ && __B__:
                    __A__ が真と判定される値の場合: __B__  #// 例: 'a' && 12 === 12
                    __A__ が偽と判定される値の場合: __A__  #// 例: ''  && 12 === ''
                __A__ || __B__:
                    __A__ が真と判定される値の場合: __A__  #// 例: 'a' || 12 === 'a'
                    __A__ が偽と判定される値の場合: __B__  #// 例: ''  || 12 === 12
                __A__ && __B__ || __C__:
                    #// 非推奨。推奨は #search: JavaScript 条件演算子
                    __A__ が真と判定され __B__ が真と判定される値の場合: __B__  #// 例: 'a' && 12 || 34 === 12
                    __A__ が真と判定され __B__ が偽と判定される値の場合: __C__  #// 例: 'a' && 0  || 34 === 34
                    __A__ が偽と判定される値の場合:                     __C__  #// 例: ''  && 12 || 34 === 34
                解説: 演算途中で boolean 型にキャストされることはありません
            条件演算子, 三項演算子 (?:):  #keyword: JavaScript 条件演算子 三項演算子
                基本: |
                    __Condition__ ? __ValueIfTrue__ : __ValueIfFalse__
                条件によって一部の属性を変える場合:
                    サンプル: |
                        const  object = {
                            a: 1,
                            b: 2,
                            ... (condition) ? {  // ... は スプレッド構文
                                c: 3,
                                d: 4,
                            } : {
                                c: 33,
                                d: 44,
                            },
                        }
                    condition が偽と判定される値の場合: |
                        const  object = {
                            a: 1,
                            b: 2,
                            c: 3,
                            d: 4,
                        }
                    condition が真と判定される値の場合: |
                        const  object = {
                            a: 1,
                            b: 2,
                            c: 33,
                            d: 44,
                        }
        for:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#loop
            配列:  #search: JavaScript array for loop
            Map:  #search: JavaScript map for loop
            iteratable: |
                let  iteratable = [10, 20, 30];
                for ( const  caseX  of  iteratable ) {
                    console.log( caseX );
                }
            index: |
                for ( var i = 0; i < array1.length; i+=1 ) {
                    array1[i];
                }
        try:  #// catch, finally  #keyword: JavaScript try exception
            Example: |
                try {
                } catch (e: any) {  // e: Error はできません
                } finally {
                }
        Promise:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Promise
    データ:  #// 数値、文字列、配列、オブジェクト、クラス
        数値:  #keyword: JavaScript number 
            文字列と数値の変換:  #search: JavaScript string number
            浮動小数から整数へ:
                切り下げ: Math.floor(1.9) === 1
                四捨五入: Math.round(1.5) === 2
                切り上げ: Math.ceil(1.1) === 2
            数字かそれ以外かの判定: #glossary: JavaScript  #keyword: JavaScript isNumber
                #// string 型または number 型なら !isNaN でよい
                numberRegularExpression:
                    const  numberRegularExpression = /^[0-9]+$/;
                    numberRegularExpression.test(keyword))
                isNaN:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/isNaN
                    const  isNumber = ! isNaN(value as any);  // as any は TypeScript の場合のみ必要
                    console.log( isNaN("")        === false );
                    console.log( isNaN("string")  === true );
                    console.log( isNaN("100s")    === true );
                    console.log( isNaN("123")     === false );
                    console.log( isNaN(123)       === false );
                    console.log( isNaN(NaN)       === true );
                    console.log( isNaN(true)      === false );
                    console.log( isNaN(false)     === false );
                    console.log( isNaN(undefined) === true );
                    console.log( isNaN(null)      === false );
                Number.isNaN:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
                    console.log( Number.isNaN("string")  === false );
                    console.log( Number.isNaN("")        === false )
                    console.log( Number.isNaN("100s")    === false );
                    console.log( Number.isNaN("123")     === false );
                    console.log( Number.isNaN(123)       === false );
                    console.log( Number.isNaN(NaN)       === true );
                    console.log( Number.isNaN(true)      === false );
                    console.log( Number.isNaN(false)     === false );
                    console.log( Number.isNaN(undefined) === false );
                    console.log( Number.isNaN(null)      === false );
                isFinite: #// 有限数  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/isFinite
                Number.isFinite: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite
                Number.isInteger:  #// 整数  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
            NaN:  #keyword: JavaScript NaN
                #snote: %programming%\スクリプト\JavaScrpt\JavaScript.svg#NaN
                説明: 数値の未定義型 NaN(Not a Number)
                    数値型で不適切な数学的演算が行われた時に返されます
                    undefined + undefined === NaN
                    0 / 0 === NaN  (例外にはなりません)
                NaN の判定:
                    条件式:
                        if ( ! NaN) // true
                        if (NaN)  // false
                    Number.isNaN:
                        Number.isNaN(NaN) === true
                        Number.isNaN("文字列") === false
                        Number.isNaN(undefined) === false
                    isNaN:  #// 非推奨。数値型以外でも true。Number.isNaN ではない
                        isNaN(NaN) === true
                        isNaN("文字列") === true  (?)
                        isNaN(undefined) === true  (?)
        文字列:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#string  #keyword: JavaScript string
            文字列と数値の変換:  #keyword; JavaScript string number
                parseInt:  #keyword: parseInt
                    parseInt( "123" ) == 123
                    parseInt( "123.9" ) == 123
                    parseInt( "-123.9" ) == -123
                    parseInt( "0x12" ) == 0x12 == 18
                    parseInt( "1A", 16 ) == 0x1A == 26
                    parseInt( "1a" ) == 1
                    parseInt( "1番目" ) == 1
                    parseInt( "a2" )   // NaN
                    parseInt( 123 ) == 123
                数字かそれ以外かの判定: #search: JavaScript isNumber
            数字かそれ以外かの判定: #search: JavaScript isNumber
            文字列の一部:
                メソッド: #glossary: JavaScript string
                    substr: 文字列.substr( start_or_last  [, length ] )
                    slice: 文字列.slice( start_or_last  [, over_or_last ] )
                    substring: 文字列.substring( start,  over )
                説明:
                    start: 開始位置、0以上。 start > over なら終了位置の次
                    start_or_last: 0以上なら左からの開始位置、マイナスなら末尾からの文字数
                    over: 終了位置の次、0以上。 start > over なら開始位置
                    over_or_last: 0以上なら終了位置の次、マイナスなら末尾を削除する長さ
                    length: 切り出す文字列の長さ。省略すると最後まで
            正規表現:  #keyword: regular expression, RegExp
                正規表現を試すサイト: #search: regular expression application
                メタ文字 一覧: . $ ^ { } [ ] ( ) | * + ? \
                RegExp (Regular_Expression クラス):
                    RegExp クラス:  #// new RegExp('abc(.*)xyz','gi')
                        バックスラッシュは '\\': new RegExp('\\.png')
                    RegExp リテラル:  #// /abc(.*)xyz/gi
                        バックスラッシュは \: /\.png/
                    参考:
                        snote:
                            Windows: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Regular_Expression
                            mac: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Regular_Expression
                        MDN: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec#description
                    exec:  #keyword: JavaScript RegExp exec
                        サンプル: match = /abc(.*)xyz/gi.exec( "123abc456xyz789" );
                        最初にマッチした部分だけ処理します:
                            #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#exec_Regular_Expression
                        次にマッチする部分を検索します:
                            ループにしない場合: |
                                re = new RegExp( "abc([0-9]+)xyz","gi" );

                                match = re.exec( "123abc456xyz789-987abc654xyz321" );
                                // match[0] == "abc456xyz"
                                // match[1] == "456"
                                // index == 3  // "a"
                                // input == "123abc456xyz789-123abc456xyz789" );
                                // lastIndex == 12  // "7"

                                match = re.exec( "123abc456xyz789-987abc654xyz321" );
                                // match[0] == "abc654xyz"
                                // match[1] == "654"
                                // index == 19  // "a"
                                // input == "123abc456xyz789-123abc456xyz789" );
                                // lastIndex == 28  // "3"

                                match = re.exec( "123abc456xyz789-987abc654xyz321" );
                                // match === null
                            ループにする場合: |
                                var  text, rex, match;

                                text = "function  sub1(){}\nfunction  sub2(){}";

                                rex = new RegExp("function[ \r\n]+([a-zA-Z_][a-zA-Z_0-9]*)\\(","ig");
                                rex.lastIndex = 0;

                                var  match: RegExpExecArray | null = null;
                                while ( (match = rex.exec( text )) !== null ) {
                                    echo( match[1] );  // "sub1", "sub2"
                                }
                        返り値:
                            - 返り値[0] は、正規表現全体にマッチしたテキストです。
                            - 返り値[1～] は、正規表現の ( ) の部分に対応した Text の一部が格納されます。
                                数指定子 * を指定して 0個にマッチした場合、* の左のカッコの部分には undefined が格納されます。
                                    match = /((a)*)b/.exec('b')
                                        match[0] === 'b'        // マッチした全体
                                        match[1] === ''         // (a)* の部分
                                        match[2] === undefined  // a の部分
                                返り値のインデックスは ( ) のツリー構造における深さ優先で数えます。
                                    match = /((a)(b))((c)(d))/.exec('abcd')
                                        match[0] === 'abcd'
                                        match[1] === 'ab'
                                        match[2] === 'a'
                                        match[3] === 'b'
                                        match[4] === 'cd'
                                        match[5] === 'c'
                                        match[6] === 'd'
                            - 返り値.index は、Text の中で、マッチした位置（０～）です。
                            - 返り値.input は、Text と同じです。
                            - (RegExp object).lastIndex は、Text の中で、マッチした位置の次の位置（０～）です。
                                /___/g の g の指定がないときは常に0です。
                            - 見つからなかったら、返り値は null です
                    指定した文字列の前までにマッチさせます:  #keyword: RegExp 否定文字列
                        方法: #// 文字列を（肯定後読みで）検索し、.* の部分を正規表現以外で処理します。
                            サンプル: |
                                //                                       012345678901234567
                                console.log((new RegExp('( #|$)')).exec('#the pattern# #end').index)  // 13
                                console.log((new RegExp('( #|$)')).exec('#the pattern# #end #').index)  // 13
                                console.log((new RegExp('( #|$)')).exec('#the pattern# end').index)  // 17
                                console.log((new RegExp('( #|$)')).exec('#the #end').index)  // 4
                                console.log((new RegExp('( #|$)')).exec('#the').index)  // 4

                                const  text = '#the pattern# #end';
                                const  replacedPart = '(cut)';
                                const  startIndex = 0  // start of .* part
                                const  overIndex = (new RegExp('( #|$)')).exec(text).index;

                                const  replaced = text.substr(0, startIndex) + replacedPart + text.substr(overIndex);
                                console.log(replaced);  // "(cut) #end"
                        不完全な方法: #// 肯定先読みをします
                            サンプル: |
                                console.log((new RegExp('.*(?= #)')) .exec('#the pattern# #end'))    // OK '#the pattern#'
                                console.log((new RegExp('.*(?= #)')) .exec('#the pattern# end'))     // NG null
                                console.log((new RegExp('.*(?= #)')) .exec('#the pattern# #end #'))  // NG '#the pattern# #end'
                                console.log((new RegExp('.*(?= #)')) .exec('#the pattern# end #'))   // OK '#the pattern# end'
                                console.log((new RegExp('(?! #)*'))  .exec('#the pattern# #end #'))  // NG ''
                                console.log((new RegExp('.*(?= #)?')).exec('#the pattern# #end'))    // NG '#the pattern# #end'
                                console.log((new RegExp('.*(?= #)?')).exec('#the pattern# end'))     // OK '#the pattern# end'
                            参考:
                                .*(?!ed) は .* と同じ動作をします: #keyword: wildcard negative lookahead
                                    問題:
                                        否定先読みの前のパターンマッチング（.*(?!ed) の .*）をした後、
                                        それに続く先読みパターン（.*(?!ed) の ed）がマッチしなかったら、
                                        再検索（.*(?!ed) の .* に戻ることを）します。
                                        また、先読みする部分が末尾より後だったらマッチします。
                                    対策:
                                        先読みパターン（.*(?!ed) の ed）を検索し、
                                        .* の部分を正規表現以外で処理します。
                                        #search: RegExp 否定文字列
                                    その他実験結果: |
                                        console.log((new RegExp('[^#]*'      )).exec('the pattern# #end'))  // "the pattern"
                                        console.log((new RegExp('[^ #]*'     )).exec('the pattern# #end'))  // "the"
                                        console.log((new RegExp('[^( #)]*'   )).exec('the pattern# #end'))  // "the"
                                        console.log((new RegExp('([^ ][^#])*')).exec('the pattern# #end'))  // "the patter"

                                        // 否定的先読み
                                        console.log((new RegExp('^(?!.*pattern).*$' )).exec('the pattern# #end'))  // null
                                        console.log((new RegExp('^(?!.*pattern).*$' )).exec('the Pattern# #end'))  // "the Pattern# #end"
                肯定先読み, 否定先読み（否定的先読み）, 肯定後読み, 否定後読み（否定的戻り読み）:  #keyword:
                    注意: 肯定先読み、肯定後読みは、正規表現の ( ) と exec の返り値[1～] でも同様のことができます
                        #search: RegExp exec
                    肯定先読み: #// (?=__Pattern__)
                    否定先読み: #// (?!__Pattern__)  #// negative lookahead
                    肯定後読み: #// (?<=__Pattern__)
                        サンプル: |
                            console.log((new RegExp('(?<= |^)#')).exec('#if:').index)  // 0
                            console.log((new RegExp('(?<= |^)#')).exec(' #if:').index)  // 1      #disable-tag-tool:
                            console.log((new RegExp('(?<= |^)#')).exec('p#if:'))  // null
                            console.log((new RegExp('(?<= |^)#')).exec('p #if:').index)  // 2     #disable-tag-tool:
                            console.log((new RegExp('(?<= |^)#')).exec('  #if:').index)  // 2     #disable-tag-tool:
                    否定後読み: #// (?<!__Pattern__)
                    行の一部:
                        指定した単語の直後が指定したパターン, 指定した単語まで >> 肯定先読み:
                            サンプル: |
                                console.log((new RegExp('play(?=ed)')).exec('play played').index)
                                    // 5
                                console.log((new RegExp('.*(?=ed)')).exec('play played').index)
                                    // 0
                                console.log((new RegExp('.*(?=ed)')).exec('play played'))
                                    // 'play play'
                        指定した単語の直後が指定したパターン以外 >> 否定先読み:
                            サンプル: |
                                const  re = new RegExp('play(?!ed)','g');
                                const  text = 'play plays playe played playede play';
                                //             0123456789012345678901234567890123456
                                r = re.exec(text);  console.log( r[0], r.index, re.lastIndex)  // "play" 0 4
                                r = re.exec(text);  console.log( r[0], r.index, re.lastIndex)  // "play" 5 9
                                r = re.exec(text);  console.log( r[0], r.index, re.lastIndex)  // "play" 11 15
                                r = re.exec(text);  console.log( r[0], r.index, re.lastIndex)  // "play" 32 36
                                r = re.exec(text);  console.log( r )  // null
                            任意の文字列の直後が指定したパターン以外:
                                .*(?!ed) は .* と同じ動作をします: #search: wildcard negative lookahead
                            参考:
                                https://it-ojisan.tokyo/regex-not/
                        指定した単語の直前が指定したパターン >> 肯定後読み:
                            ❗注意: Safari は未対応（下記）
                            サンプル: |
                                console.log((new RegExp('(?<=ex)change')).exec('change exchange').index)
                                    // 9
                                console.log((new RegExp('(?<=ex)change')).exec('exchange change').index)
                                    // 2
                            互換性:
                                未対応: Safari 2021-09
                                対応: Chrome 2021-09
                        指定した単語の直前が指定したパターン以外 >> 否定後読み:
                            ❗注意: Safari は未対応（下記）
                            サンプル: |
                                console.log((new RegExp('(?<!ex)change')).exec('exchange change').index)
                                    // 9
                                    // ex から始まらない change
                            互換性:
                                未対応: Safari 2021-09
                                対応: Chrome 2021-09
                    行単位:
                        〜を含まない行: ^(?!.*__Pattern__).*$
                        〜または〜を含まない行: ^(?!.*(__PatternA__|__PatternB__)).*$
                        〜で始まらない行: ^(?!__Pattern__).*$
                        〜で終わらない行: ^(?!.*__Pattern__$).*$
                        〜を含むが、〜を含まない行: ^(?=.*__Contains__)(?!.*__NotContains__).*$
                エスケープする: #// 正規表現の特殊文字を検索キーワードに含めます  #serach: escapeRegularExpression
                参考: #ref: ${programming}/検索技術、DB/正規表現.svg
            replace:  #keyword: JavaScript string replace
                複数マッチさせるとき: 第1引数は g オプションが付いた正規表現を指定してください
                第2引数が文字列のとき:
                    第2引数に '$' を含まないとき: 置き換えた後の文字列
                    第2引数に '$' を含むとき: |  #// $ はエスケープ文字です。$ に置き換えるときは $$ を指定してください
                        - console.log("abc".replace(/(b)/g, '($1)'));  // "a(b)c"
                        - '$,$'.replace(/\$/g,'$$')
                第2引数が関数のとき: #// 関数の引数にマッチした状況に関する情報が入り、関数の返り値にマッチした部分が置き変わります
                    サンプル: |
                        after = before.replace(/(\\+)([^\$\\ ]|$)/g, (match, group1, group2, offset, before) => {
                            return  group1.replace(/\\/g,'/') + group2;  // replace \\ to /
                        });
                    arguments を使うサンプル: |  #search: js arguments
                        after = before.replace(/(\\+)([^\$\\ ]|$)/g, function() {
                            const  match = arguments[0];
                            const  offset = arguments[arguments.length - 2];
                            const  before = arguments[arguments.length - 1];
                            return  arguments[1];
                        });
                    match: マッチした文字列。before の一部
                    offset: マッチした位置。0 = before の 1文字目
                    参考: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter
                一部を置き換えるとき:  置き換えない部分をそのまま置き換えた後に指定します
                参考:
                    #// https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/replace
                    #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#string::replace
            repeat: |  #// 同じ文字の連続
                ' '.repeat(5)  #// 空白 5文字
            startsWith: |  #keyword:  #// 前方一致判定
                "abc".startsWith("ab") === true
                "abc".startsWith("b") === false
                "abc".startsWith("") === true
            endsWith:  #keyword:  #// 後方一致判定
            pretty-format: #keyword:
                概要: ツリー状のオブジェクトの値を文字列にします
                GitHub: #ref: https://github.com/facebook/jest/tree/main/packages/pretty-format#usage-with-plugins
            シークレット, 秘密情報: #keyword:
                dotenv: #keyword:
                    公式: https://github.com/motdotla/dotenv
                    プロジェクトにインストールします:
                        cd  "__Project__"
                        npm install dotenv
                    ___.ts:
                        import * as dotenv from "dotenv";
                        dotenv.config();
                        console.log(process.env.API_KEY);
                    .env ファイル: #// カレント フォルダー の .env ファイル
                        API_KEY=a
                dotenv-cli: #keyword:
                    概要: .env ファイルをクラウドに保存します
                        #ref: https://ui.dotenv.org/ui1/login
                    参考: #ref: https://dev.classmethod.jp/articles/react-dotenv-cli/
            diff: #keyword:  #ref: https://www.npmjs.com/package/diff
                インストール: npm install diff @types/diff --save
                サンプル: |
                    import * as diff from 'diff';
                    const  d = diff.diffChars('0125dd89Y', '012aa589X');
                    console.log(d);
                出力:
                    [
                        {value: "012", count: 3},
                        {value: "aa", count: 2, added: true},
                        {value: "5", count: 1},
                        {value: "dd", count: 2, removed: true},
                        {value: "89", count: 2},
                        {value: "Y", count: 1, removed: true},
                        {value: "X", count: 1, added: true},
                    ]
            ダンプ:  #keyword: JavaScript string dump hex
                (漢 字) をダンプします:
                    Array.from(new Buffer('漢 字')).map(d=>d.toString(16).toUpperCase())
        日時: #keyword: JavaScript 日時,  JavaScript 日付 時間 Date
            #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Date
            date-fns: #keyword:  #// 日付の表示形式。ブラウザーの JavaScript でも十分でしょう
                インストール: npm install date-fns
                参考: #ref: https://nextjs.org/learn/basics/dynamic-routes/polishing-post-page
        リテラル型: #// リテラル型, テンプレート リテラル 型
            リテラル型:  #keyword: リテラル型, Literal Types
                公式: #ref: https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types
                概要: 特定の値のみ代入できる型です
                サンプル:
                    - const  name = "Mario";             // name は string 型ではなく "Mario" のリテラル型です
                    - const  names = "Mario" | "Luigi";  // "Mario" のリテラル型と "Luigi" のリテラル型の和集合（Union 型）です
                    - const  numbers = 0 | 1 | 2;
                    - const  n = number | "default";     // number 型と "default" のリテラル型の和集合（Union 型）です
            Template Literal Types:  #keyword: テンプレート リテラル 型, Template Literal Types
                公式: #ref: https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html
                概要: 定義の中に変数が使えるリテラル型です
                サンプル (1): | #focus: World
                    type World = "world1";             // World 型を定義します
                    type Greeting = `hello ${World}`;  // type Greeting = "hello world1"; と同じ処理です
                サンプル (2): | #focus: Type12
                    type Type1 = "T1A" | "T1B";
                    type Type2 = "T2A" | "T2B";
                    type Type12 = `${Type1 | Type2}_id`;
                        // type Type12 = "T1A_id" | "T1B_id" | "T2A_id" | "T2B_id"; と同じ処理です
                        // 和集合はクロス乗算されます
        配列:  #keyword: JavaScript array  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Array
            公式: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Indexed_collections
            初期化: |
                const  names: string[] = [];
            追加・削除:  #// push, pop, shift, concat, splice
                追加:  #glossary: JavaScript
                    push: |  #// names.push( name );  // 最後に追加します
                        const  a = [1,2];
                        a.push(3);       // [1, 2, 3]
                        a.push(4,5);     // [1, 2, 3, 4, 5]
                        const  b = [6,7];
                        a.push(... b);  // [1, 2, 3, 4, 5, 6, 7]  // スプレッド構文
                        a.push(b);      // [1, 2, 3, 4, 5, 6, 7, [6, 7]]
                    unshift: names.unshift( name );  // 先頭に追加します
                    concat: |
                        const  arr1 = [ "a", "c" ];
                        const  arr2 = [ "b", "c" ];
                        const  arr = arr1.concat( arr2 );  // ["a", "c", "b", "c"]
                            // 最後に要素を追加した配列を返します
                削除:  #glossary: JavaScript
                    pop: const  last = names.pop();  // 空なら undefined
                    shift: const  first = names.shift();  // 空なら undefined
                    splice: const  removedItems = __Array__.splice( __DeletingPosition__, __DeletingCount__ );
                    filter: __ObjectArray__.filter(object => (object !== __RemovingObject__));
                削除と追加:  #glossary: JavaScript
                    splice: const  removedItems = __Array__.splice( __DeletingPosition__, __DeletingCount__ [, __InsertItem1__ ][, __InsertItem2__ ...] );
                        #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#splice
                空にします:  #keyword: JavaScript array empty
                    - names = [];
                    - names.length = 0;
            コピー: |
                arr2 = arr1.slice();  // copy  // 全部
                arr2 = arr1.slice(start, over);
                arr2 = arr1.obtains!.map((item)=>item!);  // item: number | null を item: number へ
            ループ:  #keyword: JavaScript array for loop
                イテレーター: |
                    for (const name of names) {
                        WScript.Echo  name
                    }
                配列番号: |
                    for (let i = 0;  i < names.length;  i+=1) {
                        WScript.Echo  value
                    }
                reduce:  #keyword: JavaScript reduce
                    基本形:
                        サンプル: |
                            const array1 = [1, 2, 3, 4];

                            const reducedValue = array1.reduce((previousReturnValue, element) => {
                                return  previousReturnValue + element;
                            });  // 1 + 2 + 3 + 4
                            console.log(reducedValue);  // 10
                        解説:
                            配列の reduce メソッドは、指定した関数 reducer を使って、以下の関数呼び出しを行います。
                                n1 = reducer(1, 2);
                                n2 = reducer(n1, 3);
                                n3 = reducer(n2, 4);
                            上記の previousReturnValue は、reduce のアキュムレーターと呼びます。
                    合計、初期値あり:
                        サンプル:
                            アロー関数の場合: |
                                const array1 = [1, 2, 3, 4];

                                const reducedValue = array1.reduce((previousReturnValue, element) => {
                                    return  previousReturnValue + element * 2;
                                }, 0);  // 0 + 1*2 + 2*2 + 3*2 + 4*2
                                console.log(reducedValue);  // 20
                            アロー関数式の場合: |
                                const array1 = [1, 2, 3, 4];

                                const sum = array1.reduce((sum, item) => (sum + item * 2),  0);  // 0 + 1*2 + 2*2 + 3*2 + 4*2
                                console.log(sum);  // 20
                        解説:
                            最初の要素も element 引数に渡されるようにするには、初期値を reduce の第3引数に指定します。
            検索:
                indexOf:  #keyword: JavaScript array indexOf
                    基本サンプル: index = myArray.indexOf('stevie');
                    サンプル: index = myArray.map((e)=>(e.hello)).indexOf('stevie');
                    参考:  #ref: https://stackoverflow.com/questions/8668174/indexof-method-in-an-object-array/38516944
                lastIndexOf:  #keyword: JavaScript array lastIndexOf
                    基本サンプル: index = myArray.lastIndexOf('stevie');
                    途中から検索します: |
                        'canal'.lastIndexOf('a');     // 3 を返す
                        'canal'.lastIndexOf('a', 2);  // 1 を返す
                    参考:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf
                findIndex:  #keyword: JavaScript array findIndex
                    概要: 条件を満たす最初の要素のインデックスを返します。見つからなかったら -1
                    基本サンプル:
                        コード: |
                            const array1 = [
                                { id: 1, value:'A'},
                                { id: 2, value:'B'},
                                { id: 3, value:'C'},
                                { id: 4, value:'B'},
                            ];

                            const  foundIndex = array1.findIndex((element) => (element.value === 'B'));
                            console.log(foundIndex);
                            console.log(array1[foundIndex]);
                        出力: |
                            1
                            Object { id: 2, value: "B" }
            ソート:  #keyword: JavaScript sort
                文字列配列のソート:
                    文字コード順: |
                        ["b","aa","c"].sort()  // ["aa","b","c"]
                    文字の長さの降順: |
                        ["b","aaa","cc"].sort((a,b)=>(b.length - a.length));  // ["aaa", "cc", "b"]
                数値のソート:
                    サンプル: |
                        const  a = [7,21];
                        a.sort((a,b)=>(a-b));  // a: [7,21]
                    降順のサンプル: |
                        const  a = [7,21];
                        a.sort((a,b)=>(b-a));  // a: [21,7]
                    引数を省略したとき: |
                        const  a = [7,21];
                        a.sort();  // a: [21,7]
                    #// sort に引数を渡さないと、Unicode 文字列に変換してから比較するため、
                    #// [7,21].sort() は [21,7] になってしまいます。
                逆順:
                    const reversed = array1.reverse();
                Map のキーでソート: #keyword: JavaScript Map sort  #search: JavaScript Map
                    キーが数値の場合:
                        map = new Map([... map.entries()].sort(([key1,_item1], [key2,_item2]) => key1 - key2));
                    キーが文字列または数値の場合:
                        map = new Map([... map.entries()].sort(([key1,_item1], [key2,_item2]) => key1 < key2 ?-1:+1));
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#sort
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#hash_sort
            フィルター:
                filter: #keyword: JavaScript filter  #// 条件を満たすすべての要素を含む配列を返します
                    __Array__.filter(item => item.age >= 18)
                find: #keyword: JavaScript find  #// 条件を満たす最初の要素を返します。見つからなければ undefined を返します
                    __Array__.find(item => item.ID === __TargetID__)
                some: #keyword: JavaScript some  #// 条件を満たす要素が1つでもあるかどうかを返します
                    __Array__.some(item => item.ID === __TargetID__)
                map:  #keyword: JavaScript map filter
                slice: #keyword: JavaScript array slice
                    コード: |
                        const array1 = [
                            {id: 1, value:'A'},
                            {id: 2, value:'B'},
                            {id: 3, value:'C'},
                            {id: 4, value:'B'},
                        ];

                        const  slice_1_3 = array1.slice(1,3);
                        console.log(slice_1_3);
                    出力: |
                        Array [Object { id: 2, value: "B" }, Object { id: 3, value: "C" }]
                先頭からいくつか:
                    #search: JavaScript array slice
            含む, 共通要素:
                includes:  #keyword: JavaScript includes
                    書式: __Array__.includes(__Key__, __StartIndex__)
                    サンプル: |
                        [11, 22, 33].includes(11)  // true
                        [11, 22, 33].includes(44)  // false
                        [11, 22, 33].includes(22, 1)  // true
                        [11, 22, 33].includes(22, 2)  // false
                共通要素:
                    for 版（推奨）: |
                        function  getCommonItemsUsingFor<T>(arrayA: T[], arrayB: T[]): T[] {
                            const  commonItems = [] as T[];
                            for (const item of arrayA) {
                                if (arrayB.includes(item)){
                                    commonItems.push(item);
                                }
                            }
                            return  commonItems;
                        }
                    reduce 版: |
                        function  getCommonItemsUsingReduce<T>(arrayA: T[], arrayB: T[]): T[] {
                            return  arrayA.reduce( (previous, item) => {
                                if (arrayB.includes(item)){
                                    previous.push(item);
                                }
                                return previous;
                            }, [] as T[]);
                        }
                    テスト: |
                        const  arrA = [ 1, 3, 5, 7 ];
                        const  arrB = [ 2, 3, 4, 5 ];
                        console.log(getCommonItemsUsingFor(arrA, arrB));    // [ 3, 5 ]
                        console.log(getCommonItemsUsingReduce(arrA, arrB)); // [ 3, 5 ]
                重複削除:  #keyword: JavaScript 重複削除
                    Map を使う場合:  #// 処理効率が良いですが、同じ要素のうちどの要素が残るかは不定です  #focus: id: 4
                        コード: |
                            const array1 = [
                                {id: 1, value:'A'},
                                {id: 2, value:'B'},
                                {id: 3, value:'C'},
                                {id: 4, value:'B'},
                            ];

                            const uniqueArray = Array.from(
                                new Map(array1.map((element) => [element.value, element])).values()
                            );
                            console.log(uniqueArray);
                        出力: |
                            Array [Object { id: 1, value: "A" }, Object { id: 4, value: "B" }, Object { id: 3, value: "C" }]
                    filter, findIndex を使う場合:  #// 処理効率が悪いですが、インデックスが小さい要素が必ず残ります
                        コード: |
                            const array1 = [
                                {id: 1, value:'A'},
                                {id: 2, value:'B'},
                                {id: 3, value:'C'},
                                {id: 4, value:'B'},
                            ];

                            const  uniqueArray = array1.filter(
                                (element, index, array) =>
                                    index === array.findIndex(
                                        (e) => (element.value === e.value)));
                            console.log(uniqueArray);
                        出力: |
                            Array [Object { id: 1, value: "A" }, Object { id: 2, value: "B" }, Object { id: 3, value: "C" }]
                    参考: #ref: https://qiita.com/allJokin/items/28cd023335641e8796c5
            差分: |
                const  array1 = [1, 2, 3, 4];
                const  array2 = [1, 2, 5, 6];

                array1minus2 = array1.filter((element) => (array2.indexOf(element) === -1));
                console.log(array1minus2); // [3, 4]

                array2minus1 = array2.filter((element) => (array1.indexOf(element) === -1));
                console.log(array2minus1); // [5, 6]
            要素の型:
                配列の型から要素の型を返します:
                    サンプル: |
                        type __ArrayType__ = (string | number | boolean)[]  // string または number または boolean を要素に持つ配列
                        type __ElementType__ = __ArrayType__[number]  // string | number | boolean になる
                    参考: https://qiita.com/suin/items/25588b2beba7a3fcce4f
                        https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html
            参考: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#Array
        Map（Map, オブジェクト, 辞書, ハッシュ）:  #keyword: JavaScript Map,  JavaScript hash,  JavaScript dictionary
            #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#hash
            オブジェクトと Map の違い:
                Map のキーは String 以外もできます:
                Map の反復処理は要素の挿入順に行われます:
                    順序が入れ替わる例: #search: parseMap
                Map は簡単にサイズを取得できます:
                参考: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Keyed_collections
            オブジェクト, 連想配列:  #keyword: 連想配列  #// {[name: string]: boolean},  object["key1"]
                型の例: |
                    {[name: string]: boolean}
                    {[__DummyName__: __IndexType__]: __ItemType__}
                ループ:  #keyword: JavaScript map for loop,  JavaScript map hash for loop
                    - for (const key of Object.keys(hash)) { ____ }
                    - for (const value of Object.values(hash)) { ____ }
                    - for (const [key, value] of Object.entries(hash)) { ____ }
                キーの有無:
                    有無の判定:
                        - if ("key" in hash) { ...
                        - if ( ! ("key" in hash)) { ...
                    無いときの動作:
                        - hash["new_key"] === undefined
                            // 実行後 Object.keys(hash) に "new_key" は含まれません
                削除:
                    delete  hash.key;
                    delete  hash["key"];
                    #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/delete
                readonly のハッシュ: |
                    {readonly [name: string]: boolean}
                辞書の値の構造を変える: #// 配列の map メソッドや filter メソッドのような処理をします
                    説明:
                        配列の map のようなメソッドはありません。なぜならオブジェクトに map メソッドを予約しないからです。
                        Object.entries を使えば map, filter, forEach などが使えます。
                        for ループで書いた方が可読性が高いかもしれません。
                    Object.fromEntries, Object.entries の場合:  #keyword: Object.fromEntries, Object.entries
                        基本: |
                            const  entries = Object.entries( {a: 1, b: 2} );
                            const  object = Object.fromEntries(entries);
                            console.log(entries);  // [["a", 1], ["b", 2]]
                            console.log(object);   // {a: 1, b: 2}
                        map: |
                            const  key = 0,  value = 1;
                            const  object = Object.fromEntries(Object.entries
                                ( {a: 1, b: 2} ).map(keyValue=>[ keyValue[key], keyValue[value] * 2 ]));
                            console.log(object);  // {a: 2, b: 4}
                        filter: |
                            const  key = 0,  value = 1;
                            const  object = Object.fromEntries(Object.entries
                                ( {a: 1, b: 2} ).filter(keyValue => (keyValue[value] === 2)));
                            console.log(object);  // {b: 2}
                        補集合: |
                            const  all = {a: 1, b: 2};
                            const  key = 0,  value = 1;
                            const  object = Object.fromEntries(Object.entries( all )
                                .filter(keyValue => (keyValue[value] === 2)));
                            const  others = Object.fromEntries(Object.entries( all )
                                .filter(keyValue => ! (keyValue[key] in object)));
                            console.log(object);  // {b: 2}
                            console.log(others);  // {a: 1}
                    for の場合: |
                        for (const [key, value] of Object.entries(hash)) {
                            newHash[key] = value.lineNum;
                        }
                    forEach の場合: |  #// 非推奨。出力が分かりにくいため
                        Object.entries( hash ).forEach(([key,value])=>{ newHash[key] = value.lineNum; });
                    reduce の場合: |
                        const  inputObject = {a: 1, c: 3};
                        const  outputObject = Object.entries(inputObject).reduce((obj, [key,value]) => {
                            obj[key] = value * 2;  return  obj; }, {});
                        console.log(outputObject);  // {a: 2, c: 6}
                #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Working_with_Objects
            Map:  #// Map<string, string>,  map.get("key1")
                TypeScript:
                    サンプル: | #ref: https://www.gesource.jp/weblog/?p=7670
                        const  map = new Map<string, string>();
                        map.set("key1", "value1");
                        map.set("key2", "value2");
                        console.log(map.size); //=> 2
                        console.log(map.get("key1")); //=> value1
                        console.log(map.get("hoge")); //=> undefined キーが存在しないとき
                        console.log(map.has("key1")); //=> true
                        console.log(map.has("hoge")); //=> false
                        console.log(map.keys()); //=> MapIterator { 'key1', 'key2' }
                        console.log(map.values()); //=> MapIterator { 'value1', 'value2' }
                        console.log(map.entries()); //=> MapIterator { [ 'key1', 'value1' ], [ 'key2', 'value2' ] }
                        for (const [key, value] of Array.from(map.entries())) {
                            console.log(key + ' goes ' + value);
                        }
                        map.forEach((value: string, key: string) => {
                            console.log(key + "=" + value)
                        });
                        map.delete("key1");
                        console.log(map.size); //=> 1
                        map.clear();
                        console.log(map.size); //=> 0
                    new:
                        - const  __Map__ = new Map<number, string>();  #// Map<number, string> type
                        - const  __Map__ = new Map<number, string>([ [1, 'value1'], [2, 'value2']]);
                    set: __Map__.set(__Key__, __Value__);
                    get: __Map__.get(__Key__);
                    has: __Map__.has(__Key__);
                    size: __Map__.size;
                    delete: __Map__.delete(__Key__);
                    clear: __Map__.clear();
                    keys: __Map__.keys();  Array.from(__Map__.keys())
                    values: __Map__.values();
                    entries: __Map__.entries();
                    for: for (const [__Key__, __Value__] of Array.from(__Map__.entries())) {
                    forEach: __Map__.forEach( () => {} );
                    merge: |
                        const  map1 = new Map<number, string>([[1, 'A'],  [3, 'B']]);
                        const  map2 = new Map<number, string>([[3, 'BB'], [7, 'C']]);
                        var merged = new Map([...map1, ...map2])
                        console.log(merged);  // [1, 'A'], [3, 'BB'], [7, 'C']]
                JavaScript:
                    サンプル: |  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Keyed_collections
                        let sayings = new Map();
                        sayings.set('dog', 'woof');
                        sayings.set('cat', 'meow');
                        sayings.set('elephant', 'toot');
                        sayings.size; // 3
                        sayings.get('dog'); // woof
                        sayings.get('fox'); // undefined
                        sayings.has('bird'); // false
                        sayings.delete('dog');
                        sayings.has('dog'); // false

                        for (let [key, value] of sayings) {
                            console.log(key + ' goes ' + value);
                        }
                        // "cat goes meow"
                        // "elephant goes toot"

                        sayings.clear();
                        sayings.size; // 0
                    new: const  __Map__ = new Map();
                    set: __Map__.set(__Key__, __Value__);
                    get: __Map__.get(__Key__);
                    has: __Map__.has(__Key__);
                    size: __Map__.size;
                    delete: __Map__.delete(__Key__);
                    clear: __Map__.clear();
                    for: for (const [__Key__, __Value__] of __Map__) {
                jest expect:
                    Map の内容を比較します:
                        Array.from, toStrictEqual: expect( Array.from(set1) ).toStrictEqual([ ["key","value"], ["key","value"] ]);
                        toBe (NG): expect(set1).toBe(set2);  #// エラーになります
                        toStrictEqual (NG): expect(set1).toStrictEqual(set2);  #// 順番が違っても Pass してしまいます
                ソート: #search: JavaScript Map sort
                関連:
                    Map のキーだけ使って重複しない配列を使うことの代わり: #search: JavaScript Set
            公式:
                Map: #ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
                TypeScript Index Signatures: #ref: https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures
        その他のコレクション:
            WeakMap: #// キーがオブジェクトのときの Map  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Keyed_collections#weakmap_object
                WeakMap にするとガベージコレクションの対象になります。
                WeakMap のキーであっても他からそのオブジェクトが参照されていなければ、ガベージコレクションの対象になります。
            Set: #keyword: JavaScript Set  #// 重複しない配列  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Keyed_collections#sets
                関連 >> 重複削除: #search: JavaScript 重複削除
                重複の判定方法: === で比較します
                サンプル 1: |
                    const  set1 = new Set<string>();
                    set1.add('A');  // ['A']
                    set1.add('B');  // ['A', 'B']
                    set1.add('A');  // ['A', 'B']
                    set1.size == 2;
                    for (let item of set1) {
                    }
                    if (set1.has('A')) {
                        set1.delete('A');
                    }
                    array1 = Array.from(set1);
                    array2 = [...set1];
                サンプル 2: |
                    const  set1 = new Set<string>(['A', 'B', 'A']);  // ['A', 'B']
                    const  set2 = new Set<string>(['A', 'C']);
                    var merged = new Set([...set1, ...set2])
                    console.log(merged);  // ['A', 'B', 'C']
                サンプル 3 (JavaScript): |  #focus: Array.from(new Set(array1))
                    class  ClassA {
                        constructor(name, num) {
                            this.name = name;
                            this.num = num;
                        }
                    }
                    const  a = new ClassA('A', 1);
                    const  b = new ClassA('B', 2);

                    var  array1 = [a, b];
                    array1.push(a);
                    console.log(array1);  // [{ name: "A", num: 1 }, { name: "B", num: 2 }, { name: "A", num: 1 }]

                    array1 = Array.from(new Set(array1));  // #search: cutSameItems
                    console.log(array1);  // [{ name: "A", num: 1 }, { name: "B", num: 2 }]
            WeakSet:
        オブジェクト、クラス:  #keyword: JavaScript object
            オブジェクト型:
                公式:
                    Object Types: https://www.typescriptlang.org/docs/handbook/2/objects.html
            class:  #keyword: JavaScript class
                関連 >> interface: #search: TypeScript interface
                定義サンプル: |
                    class Relation {
                        name: string;
                        age: number;
                        constructor( Name: string,  Age: number ) {
                            this.Name = Name;
                            this.Age = Age;
                        }
                    }
                引数なし: |
                    class Relation {
                        name = '';
                        age = 0;
                    }
                    const  object = new Relation();
                static メソッド:  #keyword: JavaScript static method
                    サンプル: |  #focus: static, ClassA
                        class ClassA {
                            static  property = 'some';
                            static  method() {
                                return 'called.';
                            }
                        }

                        const  returnValue = ClassA.method();
                        console.log(returnValue);  // called.

                        console.log(ClassA.property);  // some
                    static のみのブロック: |  #focus: static {,  property
                        class ClassA {
                            static {
                                console.log(`1: ${ClassA.property}`);  // undefined
                            }
                            static  property = 'some';
                            static {
                                console.log(`2: ${ClassA.property}`);  // some
                            }
                        }
            constructor:  #keyword: TypeScript constructor
                readonly:  #search: TypeScript readonly
                public:  #search: TypeScript constructor public
            属性:  #keyword: JavaScript attribute
                参照: | #// 属性の値を参照します
                    object.attribute  または  object['attribute']
                readonly:  #search: TypeScript readonly
                public:  #// コンストラクターに指定した引数を属性にします
                    サンプル: |  #focus: public pub  #keyword: TypeScript constructor public
                        class MyClass {
                            attribute = 1;
                            constructor(option?: number) {
                                this.attribute = option;
                            }
                        }
                        const  myObject = new MyClass(2);
                        console.log(myObject.pub);
                リテラル:
                    書式: |
                        { attribute: value }
                        または
                        { "attribute": value }
                        または
                        { [__NameExpression__]: __ValueExpression__ }
                    サンプル:
                        コード: |
                            const  attribute = 'value';
                            const  object = {
                                attribute: 1,
                                "attribute2": 2,
                                [attribute]: 3,
                            }
                        上記 object の値:
                            {
                                attribute: 1,
                                attribute2: 2,
                                value: 3,
                            }
            分割代入:  #keyword:
                配列の分割代入: |  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#array_destructuring
                    let [ a, b, ...c ] = [ 1,2,3,4,5 ];
                オブジェクトの分割代入: |  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#object_destructuring
                    let { title, width, ...other } = options;
            スプレッド構文:  #// Deep copy  #keyword: JavaScript spread operator, JavaScript スプレッド構文 スプレッド演算子,  JavaScript ...
                基本: |
                    newObject = { ...oldObject, attr: overwritingValue };
                    newObject = { ...oldObject, attr1: overwritingValue1, attr2: overwritingValue2 };
                    newObject = { ...oldObject, ...overwritingObject };
                    copyObject = { ...sourceObject };
                    copyObject = { ...undefined, ...sourceObject };  // エラーにはなりません
                説明:
                    ...: オブジェクトの展開を参照します
                一部を書き換えるサンプル: |
                    const  xyz = { x: 1, y: 2, z: 3 };

                    const  newXyz = { ...xyz,  z: 4 };
                    console.log(newXyz); 　// { x: 1, y: 2, z: 4 };}
                マージするサンプル: |
                    const xy = { x: 1, y: 2 };
                    const yz = { y: 3, z: 4 };

                    const xyz = { ...xy,  ...yz }
                    console.log(xyz);　 // { x: 1, y: 3, z: 4 };}
                応用サンプル:
                    コード: |
                        const inTheBag = {
                            grape:      { price: 200,  weight: 50, },
                            melon:      { price: 300,  weight: 20, },
                            strawberry: { price: 100,  weight: 10, },
                        };

                        const inTheCar = {
                            ...inTheBag,
                            melon: {
                                ...inTheBag.melon,
                                price: 999,
                            }
                        };
                        console.log(inTheCar);
                    出力: |
                        {
                            grape:      { price: 200, weight: 50 },
                            melon:      { price: 300, weight: 20 },
                            strawberry: { price: 100, weight: 10 }
                        }
                        {
                            grape:      { price: 200, weight: 50 },
                            melon:      { price: 999, weight: 20 },
                            strawberry: { price: 100, weight: 10 }
                        }
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#spread_syntax1
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#spread_syntax
                #// ES2018
                #// 分割代入 https://ja.javascript.info/destructuring-assignment
            Object.assign:  #// Deep copy  #keyword: Object.assign
                注意: ❗スプレッド構文を使うことを推奨します  #search: JavaScript spread operator
                #snote: %programming%\スクリプト\JavaScrpt\JavaScript.svg#Object_assign
                書式: reference = Object.assign(changingObject, addingObject);
                説明:
                    - 第1引数の内容は変化します
                    - 返り値は第1引数の参照です
                    - 第1引数がリテラルのときは、呼び出すたびにリテラルの内容のオブジェクトが生成されます
            immer: #search: immer
            オブジェクトID:  #keyword: object ID, JavaScript getObjectID
                ライブラリ: #ref: ${GitHub}/typrm/src/lib.ts#getObjectID
                参考: #ref: https://stackoverflow.com/questions/2020670/javascript-object-id
            namespace:  #keyword: JavaScript TypeScript name space
                変数: |
                    // verbVar
                    namespace VerbVariable {
                        export const  file = '${file}';  // namespace の外から見えるようにするには export
                    }
                    const  verbVar = VerbVariable;  // 別名
                関数: |  #focus: NameSpace1, funcA
                    namespace NameSpace1 {
                        export function  funcA() {
                            return  'called';
                        }
                    }

                    function  main() {
                        console.log(NameSpace1.funcA());
                    }
                    main();
            namespace 的な class: |
                class Category {
                    static  method() {
                    }
                }
            immutable:  #keyword: immutable, イミュータブル
                ReadOnly<T>:  #ref: https://typescript-jp.gitbook.io/deep-dive/type-system/readonly#readonly-1
                    基本: |
                        const  this_ = this as Readonly<SettingsTree>;
                        this_.attribute = 1;  // ERROR!
                    methodImmutably:  #keyword: methodImmutably, method_Immutably
                        概要: イミュータブルなコードを増やすためのメソッド
                        サンプル: |  #focus: method_Immutably, Readonly, Example_method, this_, return_
                            class Example {
                                attributeA: string = 'A';
                                attributeB: string = 'B';
                                attributeC: string = 'C';

                                method(x: OtherX, y: OtherY) {
                                    Object.assign(this, this.method_Immutably(x, y));
                                }
                                method_Immutably(x: Readonly<OtherX>, y: Readonly<OtherY>): Example_method {
                                    const  example = this as Readonly<Example>;
                                    const  return_: Example_method = {
                                        attributeB: '',
                                        attributeC: example.attributeC,
                                    };

                                    // example.attributeA = 'ERROR';
                                    // x.attributeA = 'ERROR';
                                    // y.attributeA = 'ERROR';

                                    var  value = example.attributeA + x.attributeA + y.attributeA;
                                    value = value.toUpperCase() + example.attributeB + example.attributeC;
                                    value = value.toLowerCase() + (example.attributeB+'/') + example.attributeC;
                                    return_.attributeB = value;
                                    value = value.length.toString();
                                    value = value.toUpperCase() + example.attributeB + example.attributeC;
                                    value = value.toLowerCase() + (example.attributeB+'/') + example.attributeC;
                                    return_.attributeC = example.attributeC + value;
                                    return  return_;
                                }

                                method_Mutably(x: OtherX, y: OtherY) {
                                    var  value = this.attributeA + x.attributeA + y.attributeA;
                                    value = value.toUpperCase() + this.attributeB + this.attributeC;
                                    value = value.toLowerCase() + (this.attributeB+='/') + this.attributeC;
                                    this.attributeB = value;
                                    value = value.length.toString();
                                    value = value.toUpperCase() + this.attributeB + this.attributeC;
                                    value = value.toLowerCase() + (this.attributeB+='/') + this.attributeC;
                                    this.attributeC += value;
                                }
                            }
                            interface  Example_method {
                                attributeB: string;
                                attributeC: string;
                            };
                            class OtherX {
                                attributeA: string;
                                constructor(attributeA: string) {
                                    this.attributeA = attributeA;
                                }
                            }
                            interface OtherY {
                                attributeA: string;
                            }
                            const  x = new OtherX('X');
                            const  y: OtherY = {attributeA: 'Y'};

                            const  objectIm = new Example();
                            objectIm.method(x, y);
                            console.log(JSON.stringify(objectIm));
                                // {"attributeA":"A","attributeB":"axybcB/C","attributeC":"C8bcB/C"}

                            const  objectM = new Example();
                            objectM.method_Mutably(x, y);
                            console.log(JSON.stringify(objectM));
                                // {"attributeA":"A","attributeB":"axybcB/C/","attributeC":"C8axybcb/ccaxybcB/C/C"}
                        複数のオブジェクトの属性を変更するサンプル: |  #focus: assign, Example_mutate
                            class Example {
                                :
                                mutate(x: OtherX, y: OtherY): number {
                                    const  r = this.mutate_Immutably(x, y);
                                    Object.assign(this, r.example);
                                    Object.assign(x, r.otherX);
                                    return  r.errorCount;
                                }
                                mutate_Immutably(x: Readonly<OtherX>, y: Readonly<OtherY>): Example_mutate {
                                    const  example = this as Readonly<Example>;
                                    const  return_: Example_mutate = {
                                        example: { // this
                                            attributeB: '-',
                                            attributeC: '-',
                                        },
                                        otherX: {
                                            attributeA: '-',
                                        },
                                        errorCount: 1,
                                    };
                                    return  return_;
                                }
                            }
                            interface  Example_mutate {
                                example: { // this
                                    attributeB: string;
                                    attributeC: string;
                                },
                                otherX: {
                                    attributeA: string;
                                },
                                errorCount: number;
                            }

                            const  objectMu = new Example();
                            const  errorCount = objectMu.mutate(x, y);
                            console.log(JSON.stringify(objectMu));
                                // {"attributeA":"A","attributeB":"-","attributeC":"-"}
                            console.log(JSON.stringify(x));
                                // {"attributeA":"-"}
                            console.log(errorCount);
                                // 1
                        ミュータブルのほうが適するオブジェクトの例:
                            処理中に入出力を繰り返すもの:
                                - エラーログ
                                - 現在位置（行番号や ファイル ポインター など）
                Object.freeze:  #keyword:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
                    書式: Object.freeze(__Object__)
                    注意:
                        - オブジェクトのプロパティにあるオブジェクトや配列は対象外です  #search: deepFreeze
                    基本サンプル: |  #focus: freeze, ERROR
                        class Example {
                            attribute: number = 0;
                        }
                        const  example = new Example();
                        example.attribute = 1;  // OK

                        Object.freeze(example);
                        // example.attribute = 2;  // ERROR!
                    変更:
                        概要: |  #search: JavaScript spread operator
                            const example1 = {...example, attribute: 1 };
                        サンプル: |  #focus: freeze, ERROR  #keyword: mutate imuutable object
                            class Example {
                                attribute: number = 0;
                                constructor(attribute: number) {
                                    this.attribute = attribute;
                                }
                                setAttribute(x: number) {
                                    // this.attribute = x;  // ERROR!
                                }
                            }

                            var  example = new Example(0);
                            Object.freeze(example);
                            const example1 = {...example, attribute: 1 };  // OK
                            // Object.assign(example, {attribute: 2}); // ERROR!

                            var  example = new Example(0);
                            function useExample(example: Example) {
                                example.attribute = 1;
                                const example_ = Object.freeze({...example}) as Example;
                                // example_.attribute = 2;  // ERROR!
                                // example_.setAttribute(2);  // ERROR!
                            }
                            useExample(example);
                            example.attribute = 2;  // OK
                    トラブルシューティング:
                        発生する例外: |
                            Uncaught TypeError: Cannot assign to read only property '__attribute__' of object '#<__Class__>'
                        例外が発生した場所を調べます:
                            VSCode >> Run and Debug（左）>> BREAK POINT（左下）>> Uncaught Exceptions（にチェック）>>
                            再実行 >> .js のパスが表示されたら、ターミナルで code -g __Path__:__Line__:__Column__ を実行します
                    参考: #ref: https://www.mitsue.co.jp/knowledge/blog/frontend/202002/28_1056.html
                Object.isFrozen:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
                    const  instance = {};
                    console.log(Object.isFrozen(instance));  // false
                    Object.freeze(instance);
                    console.log(Object.isFrozen(instance));  // true
                deepFreeze:  #keyword:
                    概要: オブジェクトのプロパティにあるオブジェクトも Object.freeze します
                    サンプル: |  #focus: freeze, ERROR
                        function  deepFreeze(object: any) {

                            Object.freeze(object);
                            for (const key in object) {
                                const property = object[key];
                                if (
                                    object.hasOwnProperty(key) &&
                                    typeof property === 'object' &&
                                    property !== null
                                ) {

                                    deepFreeze(property);
                                }
                            }
                        }

                        class ExampleParent {
                            attribute: number;
                            child: Example;

                            constructor(attribute: number) {
                                this.attribute = attribute;
                                this.child = new Example(0);
                            }
                        }

                        class Example {
                            attribute: number;
                            constructor(attribute: number) {
                                this.attribute = attribute;
                            }
                            setAttribute(x: number) {
                                this.attribute = x;  // ERROR!
                            }
                        }

                        const example = new ExampleParent(0);
                        deepFreeze(example);
                        const example2 = {...example, child: { attribute: 2 }};  // OK
                        example.child.attribute = 3;  // ERROR
                        Object.assign(example, {child: { attribute: 4 }});  // ERROR
                freeze デコレーター:  #// インスタンスを全て凍結します。凍結とはすべてのプロパティを更新不能にします
                    参考: #ref: https://qiita.com/suin/items/56dfe7579509d7067e10
                    変更するとき: #search: mutate imuutable object
                    サンプル: |
                        // freeze
                        function freeze(constructor: any): any {
                            const wrapper = function () {
                                const instance = new constructor(...arguments)
                                Object.freeze(instance)
                                return instance
                            }
                            wrapper.prototype = Object.create(constructor.prototype)
                            return wrapper
                        }

                        // MutableExample
                        class MutableExample {
                            attribute: number = 0;
                            constructor(attribute: number) {
                                this.attribute = attribute;
                            }
                            setAttribute(x: number) {
                                // this.attribute = x;   // ERROR!
                            }
                        }

                        // Example
                        @freeze
                        class Example extends MutableExample {
                        }

                        // example
                        const example = new Example(0);
                        console.log(example.attribute);
                        example.setAttribute(1);
                        // example.attribute = 1;   // ERROR!

                        // exampleM
                        const exampleM = new MutableExample(0);
                        exampleM.attribute = 1;   // OK
                immer: #keyword:
                    公式:
                        Document: #ref: https://immerjs.github.io/immer/
                        GitHub: #ref: https://github.com/immerjs/immer
                    produce:  #// 変更前のオブジェクトから変更後のオブジェクトを作ります。
                        サンプル: |
                            const nextState = produce(baseState, draftState => {
                                draftState.push({title: "Tweet about it"})
                            })
                        サンプル全体: #ref: https://immerjs.github.io/immer/produce
                        未確認: baseState はイミュータブル？
        interface:  #keyword: TypeScript interface
            概要: オブジェクトに必要なプロパティとその型を指定します。オブジェクト型の一種
            関連 >> class: #search: JavaScript class
            基本:
                サンプル: |
                    interface Member {  // Member インターフェース
                        name: string;  // name プロパティ
                        level: number;
                    }

                    let apple: Member = {
                        name: "りんご",
                        level: 1
                    };

                    let lemon: Member = {  // エラー。name プロパティがないため
                        level: 2
                    };
            ネスト構造:
                サンプル:  #// 下記は同じ構造です
                    ネストした部分を中に書く場合: |  #// 型名は指定できません
                        interface Member {  // Member インターフェース
                            name: string;  // .name
                            nest: {  // nest は無名ですが型の構造はチェックされます
                                level: number;  // .next.level
                            }
                        }
                    ネストした部分を外に書く場合: |  #// 型名が必要です
                        interface Member {  // Member インターフェース
                            name: string;  // .name
                            nest: MemberNest;
                        }
                        interface MemberNest {  // MemberNest インターフェース
                            level: number;  // .next.level
                        }
            プロパティ修飾子: #keyword: TypeScript property modifier
                オプションのプロパティ: #keyword: TypeScript optional properties, TypeScript オプションのプロパティ
                    概要: 無くてもよいプロパティだが、有るときは特定の型であることを指定します
                    サンプル: |
                        interface Member {
                            name?: string;  // オプションのプロパティ。string | undefined 型になります
                            level: number | undefined;  // undefined との Union 型であってもプロパティは必要です
                        }

                        let apple: Member = {
                            name: "りんご",
                            level: 1
                        };

                        let lemon: Member = {  // name プロパティがなくてもエラーにはなりません。name プロパティは undefined になります
                            level: 2
                        };

                        let melon: Member = {  // エラー。level プロパティがないからです
                            name: "メロン"
                        };
                    公式:
                        Optional Properties: https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties
                リード オンリー プロパティ: #keyword: TypeScript readonly
                    概要:
                        - プロパティに指定できる const のようなものです
                        - constructor の中から値を変更することはできます
                        - メソッドの中から値を変更することはできません
                        - 静的にチェックします。トランスパイルした後は変更できてしまいます
                    サンプル: |  #focus: readonly, name
                        interface Member {
                            readonly  name: string;  // リード オンリー
                        }

                        let apple: Member = {
                            name: "りんご",
                        };

                        apple.name = "アップル";  // エラー
                    コンストラクターに指定する場合: |  #focus: readonly,  rdata,  public readonly
                        class MyClass {
                            constructor( readonly rdata: number,  public readonly pub: number ) {  // public は有っても無くても同じ
                            }
                            get(): number {
                                return this.rdata;
                            }
                        }
                    公式:
                        readonly Properties: https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties
                    参考: #ref: https://typescript-jp.gitbook.io/deep-dive/type-system/readonly
                オブジェクト内で変更可能、オブジェクト外から変更不可にするとき:
                    ____.ts : |
                        class  ____ {
                            private  member_: number = 0;
                            get      member() {return this.member_;}
                        }
            extends: #// プロパティの追加  #keyword: TypeScript extends
                概要: プロパティを継承します
                サンプル: |
                    interface Parent {
                        name: string;
                        street: string;
                    }
                        
                    interface Address extends Parent {  // 下記 AddressWithoutExtends と同じプロパティの構成です
                        city: string;
                        country: string;
                    }

                    interface AddressWithoutExtends {
                        name: string;
                        street: string;
                        city: string;
                        country: string;
                    }
                公式:
                    Extending Types: https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-types
            交差型(&): #keyword: TypeScript 交差型
                概要: 両者のプロパティを合わせたインターフェース
                サンプル: |
                    interface Colorful {
                        color: string;
                    }
                    interface Circle {
                        radius: number;
                    }
                    
                    type ColorfulCircle = Colorful & Circle;

                    let circle: ColorfulCircle = {  // 両方のプロパティが必要
                        color: 'a',
                        radius: 9
                    }

                    let circle2: ColorfulCircle = {  // エラー。radius がないため
                        color: 'a'
                    }
                公式:
                    Intersection Types: https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types
            公式:
                Object Types: https://www.typescriptlang.org/docs/handbook/2/objects.html
        type: #//（正式名不明） #keyword: TypeScript type
            概要: type __Type__ = number のように宣言した __Type__。
                VSCode で __Type__ にカーソルを合わせると、type __Type__ = __PrimitiveTypes__ が表示されます。
                トランスパイルされたら無くなります
            __Type__[]: __Type__ 型の配列
            __ArrayType__[number]: #// 配列型の場合  #// __ArrayType__ の要素の型
                概要: 配列型に対して [number] を付けると、その配列の要素の型になります
                サンプル: |
                    type __ArrayType__ = (string | boolean)[]
                    type __ElementType__ = __ArrayType__[number] 　// type = string | boolean
            __ObjectType__[__PropertyName__]: #// オブジェクト型の場合  #// __ObjectType__ のプロパティの型
                オブジェクト型の場合:
                    概要: オブジェクト型に対して ["__PropertyName__"] を付けると、プロパティの型になります
                    サンプル: |
                        type Person = { age: number;  name: string;  alive: boolean };
                        type Age = Person["age"];
                        type I1 = Person["age" | "name"];  // type I1 = string | number
                        type I2 = Person[keyof Person];    // type I2 = string | number | boolean
                    エラー ケース (1): |
                        type Person = { age: number;  name: string;  alive: boolean };
                        Person.age  // エラー
                    エラー ケース (2): |
                        type   Person = { age: number;  name: string;  alive: boolean };
                        const  key1 = "age";
                        type   Age1 = Person[key1];  // エラー
                        type   key2 = "age";
                        type   Age2 = Person[key2];  // エラーではありません。type = number
                公式:
                    Indexed Access Types: #keyword:  #ref: https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html
        type-predicates:  #keyword: type-predicates, 型ガード
            TypeScriptの型定義から型ガードを自動生成する type-predicates-generator の紹介: #ref: https://zenn.dev/kimuson/articles/type_predicates_generator
        Union 型: #keyword: TypeScript Union, 合併型(?)  #// 複数の型のうちどれか1つの型の値をとりうる型
            複数の型:
                サンプル: |
                    type  MyType = number | string;
                    var  variable: MyType;
                    variable = 1;     // OK
                    variable = 'a';   // OK
                    variable = true;  // エラー
                参考: https://typescript-jp.gitbook.io/deep-dive/type-system/discriminated-unions
            複数の値:
                サンプル: |
                    type  SelectType = "a" | "b";
                    var  select: SelectType;
                    select = "a";  // OK
                    select = "b";  // OK
                    select = "c";  // エラー
            enum の代わりとしての Union 型:
                基本:
                    定義: |
                        const Color = {
                            Red: 0,
                            Green: 1,
                            Blue: 2
                        } as const;
                        type Color = typeof Color[keyof typeof Color]; // 0 | 1 | 2
                    参照と代入: |
                        const color = Color.Red;
                    注意: | #// var で宣言した変数の値を変更できるようにするには、変数名の右に型を書く必要があります
                        var color:Color = Color.Red;  // color = Color.Red にすると、下記のエラーになります
                        color = Color.Green;  // Error: Type '1' is not assignable to type '0'.ts(2322)
                        console.log(color);
                参考:
                    enum と Union 型の比較: #search: TypeScript enum Union
        enum:
            基本:
                定義: |
                    enum CardSuit {
                        Clubs,    // 0
                        Diamonds, // 1
                        Hearts,   // 2
                        Spades    // 3
                    }
                参照と代入: |
                    const cardSuit: CardSuit = CardSuit.Clubs;
            開始値指定: |
                enum Color {
                    DarkRed = 3,  // 3
                    DarkGreen,    // 4
                    DarkBlue      // 5
                }
            文字列の値: |
                enum EvidenceTypeEnum {
                    UNKNOWN = '',
                    PASSPORT_VISA = 'passport_visa',
                    PASSPORT = 'passport',
                    SIGHTED_STUDENT_CARD = 'sighted_tertiary_edu_id',
                }
            Unicode 文字のシンボル: |
                enum TestID {
                    あ = "a",
                    し = "shi",
                }
                var id = TestID.し;
                console.log(id); // shi
            enum と Union 型の比較: #keyword: TypeScript enum Union
                比較表: |
                    項目              enum  Union
                    -------------------------------
                    数値の省略         OK    NG
                    型推論            OK    NG
                    数値の値チェック    NG    OK
                    文字列の値チェック  OK    OK
                    ビット フラグ      OK    NG
                    可読性            Good  Bad
                    文字列値の冗長     ?     ?
                number 型の値の場合: |
                    // enum
                    enum CardSuit {
                        Clubs,    // 0
                        Diamonds, // 1
                        Hearts,   // 2
                        Spades,   // 3
                    }
                    var cardSuit = CardSuit.Clubs;  // 型推論が行われます。cardSuit:CardSuit = CardSuit.Clubs にしなくてよい
                    cardSuit = CardSuit.Diamonds;
                    cardSuit = 99;  // 範囲外の値を代入できてしまいます。CardSuit.____ を使えばそのミスは無くなります
                    console.log(cardSuit);  // 99
                    console.log(cardSuit.toString());  // 99

                    // Union
                    const Color = {
                        Red: 0,
                        Green: 1,
                        Blue: 2,
                    } as const;
                    type Color = typeof Color[keyof typeof Color]; // 0 | 1 | 2

                    var color:Color = Color.Red;  // color = Color.Red にすると、下記のエラー2322になります
                    color = Color.Green;  // 上記型指定が無いと rror: Type '1' is not assignable to type '0'.ts(2322)
                    // color = 99;  // 範囲外の値を代入しようとすると警告してくれます
                    console.log(color);  // 1
                    console.log(color.toString());  // 1
                ビット フラグ（論理和）として使う number 型の値の場合: |
                    // enum
                    enum Permission {
                        Read    = 1,
                        Write   = 2,
                        Execute = 4,
                    }
                    var cardSuit = Permission.Read;
                    cardSuit = Permission.Execute | Permission.Read;
                    console.log(cardSuit);  // 5
                    cardSuit = 99;  // 範囲外の値を代入できてしまいます。CardSuit.____ を使えばそのミスは無くなります
                    console.log(cardSuit);  // 99

                    // Union　（使えません）
                    const Color3 = {
                        Blue: 1,
                        Green: 2,
                        Red: 4,
                    } as const;
                    type Color3 = typeof Color3[keyof typeof Color3]; // 1 | 2 | 4

                    var color:Color3 = Color3.Blue;  // color = Color.Red にすると、下記のエラー2322になります
                    // color = Color3.Red | Color3.Blue;  // 上記型指定が無いと Error: Type 'number' is not assignable to type 'Color3'.ts(2322)
                    // color = 99;  // 範囲外の値を代入しようとすると警告してくれます
                    console.log(color);  // 1
                string 型の値の場合: |
                    // enum
                    enum CardSuit {
                        Clubs    = 'クローバー',
                        Diamonds = 'ダイヤ',
                        Hearts   = 'ハート',
                        Spades   = 'スペード',
                    }
                    var cardSuit = CardSuit.Clubs;
                    cardSuit = CardSuit.Diamonds;
                    // cardSuit = 'ジョーカー';  // 範囲外の値を代入しようとすると警告してくれます
                    console.log(cardSuit);  // ダイヤ

                    // Union
                    const Color = {
                        Red:   '赤',
                        Green: '緑',
                        Blue:  '青',
                    } as const;
                    type Color = typeof Color[keyof typeof Color]; // '赤’ | ’緑’ | '青'

                    var color:Color = Color.Red;  // color = Color.Red にすると、下記のエラー2322になります
                    color = Color.Green;  // 上記型指定が無いと Error: Type '1' is not assignable to type '0'.ts(2322)
                    // color = '透明';  // 範囲外の値を代入しようとすると警告してくれます
                    console.log(color);  // 緑
                参考:
                    #ref: https://www.kabuku.co.jp/developers/good-bye-typescript-enum
            #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#enum
        ジェネリクス: #keyword: TypeScript JavaScript generics
            効果: any にはできない、静的エラーチェックや、エディタの補完を行います
                TypeScript の仕様です。実行時（JavaScript）では型情報は失われます。
            サンプル:  #// 呼び出し元が指定した引数の型から、呼び出し元は、返り値の型が分かります
                呼び出し元: |  #focus: Type
                    const  initialValue = "";  // string
                    const  returnValue = lazyInit(initialValue);  // Type = string
                    console.log(returnValue.length);  // .length が候補に出てくる
                呼び出し先: |
                    function lazyInit<Type>(init: () => Type): () => Type {
                        let cache: Type;
                        let isInit = false;
                        return function(): Type {
                            if (!isInit) {
                                cache = init();
                                isInit = true;
                            }
                            return cache;
                        }
                    }
            参考: #ref: https://future-architect.github.io/typescript-guide/generics.html#any-unknown
        typeof, instanceof, hasInterfaceOf:
            typeof:
                string, number, boolean, object, function, undefined のいずれか
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#typeof
            instanceof:
                概要:
                    - 変数 var が type に指定された関数（クラス）から生成されたオブジェクトかどうかを boolean で返します。
                    - var がオブジェクト型ではないときは、常に false を返します。
                    - TypeScript でなくても JavaScript でも使えます。
                使える判定: Array
                使えない判定: string
                #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/instanceof
                #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#instanceof
            hasInterfaceOf: #keyword: TypeScript ユーザー定義 タイプ ガード hasInterfaceOf
                概要: 動的にインターフェースを判定します
                サンプル: |  #// 下記 hasInterfaceOf の中の関数がユーザー定義 タイプ ガード です
                    class MyError {
                        message2: string;
                        stack: string = '/';

                        constructor(message: string) {
                            this.message2 = message;
                        }
                    }
                    interface IMyError {
                        message2: string;
                        stack: string;
                    }

                    namespace  hasInterfaceOf {
                        export function  Error(object: any): object is Error {
                            return (
                                object.hasOwnProperty('message')
                            );
                        }
                        export function  IMyError(object: any): object is MyError {
                            return (
                                object.hasOwnProperty('message2') &&
                                object.hasOwnProperty('stack')
                            );
                        }
                    }
                    const  e = new Error('example');
                    const  me = new MyError('example');

                    const  r1 = e instanceof Error;      // true
                    const  r2 = e instanceof MyError;    // false
                    const  r3 = me instanceof MyError;   // true
                    //var  r4 = me instanceof IMyError;  // エラー。instanceof に interface を指定できないため
                    const  r5 = hasInterfaceOf.Error(e);      // true
                    const  r6 = hasInterfaceOf.IMyError(e);   // false
                    const  r7 = hasInterfaceOf.Error(me);     // false
                    const  r8 = hasInterfaceOf.IMyError(me);  // true
                参考: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#user_defined_type_guard
    関数:  #keyword: JavaScript function 関数
        (?), 引数の省略:  #keyword: TypeScript optional parameter,  TypeScript optional argument
            基本サンプル: |  #focus: ?, myFunction
                function  myFunction(option?: number): number | undefined {
                    return option;
                }
                const  r0 = myFunction();  // r0 の値は undefined, r0 の型は number | undefined
                const  r1 = myFunction(1); // r0 の値は 1,         r0 の型は number | undefined
            (?)付きの引数の後に(?)が無い引数を指定することはできません:  #focus: ?
                OK: |
                    function  myFunction(option1?: number, option2?: number)
                NG: |
                    function  myFunction(option?: number, argument: number)  // エラー A required parameter cannot follow an optional parameter.ts(1016)
        定義位置: #keyword: JavaScript function 巻き上げる
            上下:
                定義を下に書く場合（巻き上げる）: |  #// 正しく動作します
                    console.log(square(5));
                    function  square(n) { return n * n }
                定義を下に書けない場合: |  #// エラーになります
                    console.log(square(5));
                    const  square = function(n) { return n * n }
                参考: #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Functions#calling_functions
            関数内定義: |
                function  area(r) {
                    return  3.14 * _square(r);
                    _square(n) { return n * n }  // これを呼び出せる範囲は area 関数内だけです。
                }
        アロー関数式:  #ref: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Functions/Arrow_functions
            概要: 名前の付いていない関数
            書式:
                - (__Argument__) => __ReturnValue__  #// 名前のない関数
                - __Argument__ => __ReturnValue__    #// 名前のない関数
                - const  __FunctionName__ = __Argument__ => __ReturnValue__  #// 変数に代入したことで名前が付いた関数
                - (__Argument1__, __Argument2__) => __ReturnValue__
                - () => __ReturnValue__  #// 引数なしの関数
                - () => { __Statement__ }  #// 処理をする関数
                - () => void  #// 未確認
                - __Argument1__ => __Argument2__ => __ReturnValue__  #search: JavaScript double arrow
            連続するアロー:  #keyword: JavaScript double arrow
                __Argument1__ => __Argument2__ => __ReturnValue__:
                    意味: 「引数 __Argument2__ を取り __ReturnValue__ を返す関数」を返す関数。その引数は __Argument1__
                    用途:
                        例1: 返される関数の引数は __Argument2__ の 1つですが、その関数の処理内容は引数 __Argument1__ の影響を受けたものにしたいとき
                        例2: オブジェクト __Argument1__ に対する追加メソッドに相当する処理を、オブジェクトの指定なしで呼び出せる関数
                            exMethod = anObject => parameter1 => return_value;
                            exMethod( parameter );
                    参考: #ref: https://teratail.com/questions/71006
        関数型: #keyword: TypeScript function type
            サンプル: |
                type LongHand = { (a: number): number; }
            関数の引数に関数を受け取る: |
                function  replaceFileSync( replaceFunction: {(text: string): string})
        分割代入を使った関数のオプション引数:
            サンプル: |
                function  configure({title = "Untitled", width = 200, height = 100, items = [] as number[]} = {}) {
                    console.log(`title:  ${title}`);  // Hello
                    console.log(`width:  ${width}`);  // 250
                    console.log(`height: ${height}`); // 100
                    console.log( items );             // 1, 2
                }
                configure({width: 250, items: [1, 2], title: "Hello"});
                configure();
            参考:
                Destructuring and Function Arguments: #ref: https://davidwalsh.name/destructuring-function-arguments
                Destructuring Assignment In A Function Parameter: #ref: https://blog.eligarlo.dev/destructuring-assignment-in-a-function-parameter
                スマートな関数パラメーター: #ref: https://ja.javascript.info/destructuring-assignment#ref-452
        arguments:  #keyword: js arguments
            関数の引数が入った配列
    import, export, require: #keyword: JavaScript import, TypeScript import, JavaScript TypreScript export require
        TypeScript の場合:
            import from '@/':
                #search: tsconfig.json paths
            ES modules の場合、import に .js を付けないとエラーになる問題:  #keyword: TypeScript import .js
                解説: #ref: https://blog.zelkova.cc/2021/10/typescript-esmodules.html
                対策:
                    babel: 未確認
                        #ref: https://www.npmjs.com/package/babel-plugin-module-extension-resolver
                        #ref: https://www.white-space.work/using-babel-plugin-module-resolver/
                    ブラウザー: 未確認  #ref: https://github.com/WICG/import-maps
            名前空間:  #search: JavaScript namespace
        ES modules の場合:
            ES modules, ESM: #keyword: ES modules, ESM, JavaScript import, JavaScript export default
                概要: JavaScriptファイルから別のJavaScriptファイルを読み込む仕組み。ES2015以上。
                    Node.jsとブラウザの両方に対応。
                JavaScript の import と export:
                    関数:
                        import render from './render.js';
                        export function  render() {}
                    変数:
                        #ref: https://stackoverflow.com/questions/36261225/why-is-export-default-const-invalid
                HTML の script:
                    <script type="module" src="./main.js"></script>
                    <script nomodule src="./nosupport.js"></script>  #// ES modules に対応していないブラウザーの場合
                参考:
                    import 文に拡張子を書いていないとき:  #search: JavaScript import extension
                    ES modules基礎知識: #ref: https://www.codegrid.net/articles/2017-es-modules-1/
                    Customizing ESM specifier resolution algorithm: #ref: https://nodejs.org/api/esm.html#customizing-esm-specifier-resolution-algorithm
            tsconfig.json: |
                "type": "module" #// ESM
            ESM から CJS を読み取る:
                #ref: https://numb86-tech.hatenablog.com/entry/2020/08/07/091142
        CommonJS の場合:
            CommonJS, CJS: #keyword CommonJS, CJS, JavaScript require  #// CommonJS は ES module より古い仕様です
                exports.__ExportingName__: #focus: __ExportingName__
                    source.js:
                        サンプル:
                            const __Target__ = require('./target');
                            __Target__.__ExportingName__;
                        参考: #ref: https://github.com/facebook/jest/tree/main/packages/pretty-format#usage-with-plugins
                    target.js: |
                        exports.__ExportingName__ = __ExportingValue__;
                exports: #focus: __ExportingDefaultValue__
                    source.js:
                        const __ExportingDefaultValue__ = require('./target');
                    target.js: |
                        exports = __ExportingDefaultValue__;
        両方の場合:  #// ES modules と CommonJS
            同じフォルダーにある別の lib.ts ファイルに共通で使う関数を集めます:
                export します >> lib.ts 以外の ____.ts ファイルから import したときに参照できるシンボルを指定します:
                    lib.ts : |
                        export function  __CommonFunction__() {
                        }
                    メモ:
                        最後に export { __CommonFunction__ }; を書くと、定義にジャンプするときに 2箇所の候補が表示されてしまいます
                import します >> 参照しようとしているシンボルが export されている ____.ts ファイルを指定します:
                    ____.ts : |
                        import * as lib from "./lib";
                        lib.__CommonFunction__();
                    _____.ts : |
                        import * as lib from "./lib";
                        import { pp } from "./lib";
                        pp('debug');
                    補足: |
                        * と { pp } を 1行で書く方法はありません
                        https://stackoverflow.com/questions/45867553/es6-typescript-import-import-and-names-on-a-single-line
            lib.ts:  #keyword: lib.ts
                original: #ref: ${steps}/TypeScript.ts
                in typrm: #ref: ${GitHub}/typrm/src/lib.ts
                API:
                    ファイルの内容: #search: lib.ts file  #glossary: lib.ts
                        copyFolderSync:
                        copyFileSync:
                        replaceFileSync:
                        replaceFileAsync:
                        searchAsTextSub:  #keyword: searchOpen
                        #search: lib.ts string
                    ファイル名: #search: lib.ts file name path  #glossary: lib.ts
                        pathResolve:
                        getFullPath:
                        isFullPath:
                        checkNotInGitWorking:
                        getTestWorkFolderFullPath:
                        getGlobbyParameters:
                    文字列: #keyword: lib.ts string  #glossary: lib.ts
                        cutLeftOf:
                        cutLast:
                        cutIndent:
                        getIndentWithoutHyphen:
                        checkExpectedTextContents:
                        coloredDiff:
                        parseCSVColumns:
                        parseCSVColumnPositions:
                        escapeRegularExpression:
                        replace:
                        replaceAsync:
                        loadDotEnvSecrets:
                        getDotEnvSecrets:
                        getProcessEnvAndDotEnvSecrets:
                    データ:  #glossary: lib.ts
                        isSameArrayOf:
                        getCommonItems:
                        cutSameItems:
                        stableUniqueFilterFunction:
                        lastUniqueFilterFunction:
                        fastUniqueFilter:
                        parseMap:
                        isAlphabetIndex:
                        getAlphabetIndex:
                        fromAlphabetIndex:
                        hasInterfaceOf:
                        getObjectID:
                    ユーザーインターフェース:  #glossary: lib.ts
                        setInputOption:
                        input:
                        inputPath:
                        inputSkip:
                        cutEscapeSequence:
                        getSnapshot:
                    デバッグ: #keyword: lib.ts debug  #glossary: lib.ts
                        pp:
                        cc:
        C++ addons: #ref: https://nodejs.org/api/addons.html
        export されていない関数やクラスを参照します:  #keyword: JavaScript not exported
            間接 export:  #keyword: JavaScript export not exported private_
                概要: private_ という名前の変数を介してアクセスします。
                    言語的には export された状態です。
                    rewire などの Node パッケージに依存しないというメリットがあります。
                indirect.ts : |  #// テスト対象
                    function  notExportedFunction(argument_: string): string {
                        return  `> ${argument_}`;
                    }

                    class  NotExportedClass {
                        argument: string;

                        constructor(argument: string) {
                            this.argument = argument;
                        }

                        get(): string {
                            return  `> ${this.argument}`;
                        }
                    }

                    const  notExportedVariable = 'hello';

                    // private_
                    // For the unit test
                    export const  private_ = {
                        notExportedFunction,
                        NotExportedClass,
                        notExportedVariable,
                    };
                indirect.test.ts : |  #// テスト
                    import * as indirect from './indirect';

                    test('rewire function', () => {
                        const  notExportedFunction = indirect.private_.notExportedFunction;
                        expect(notExportedFunction('hello')).toBe('> hello');
                    });

                    test('rewire class', () => {
                        const  NotExportedClass = indirect.private_.NotExportedClass;
                        const  object = new NotExportedClass('hello');
                        expect(object.get()).toBe('> hello');
                    });

                    test('rewire variable', () => {
                        const  notExportedVariable = indirect.private_.notExportedVariable;
                        expect(notExportedVariable).toBe('hello');
                    });
                参考:
                    #ref: https://golang.hateblo.jp/entry/2021/03/12/214524
                    #search: name mangling
            rewire:  #keyword: JavaScript rewire not exported
                注意: 動作しない 2022-01-02
                公式: #ref: https://www.npmjs.com/package/rewire
                試すときのベースにするプロジェクト:  #ref: ${GitHub}/Trials/try_JestOfConsole
                rewire をプロジェクトにインストールします:
                    #// 以下のいずれか
                    - npm install --save-dev  rewire  @types/rewire
                    - yarn add --dev  rewire  @types/rewire
                example.ts : |  #// テスト対象
                    function  notExportedFunction(argument_: string): string {
                        return  `> ${argument_}`;
                    }

                    class  NotExportedClass {
                        argument: string;

                        constructor(argument: string) {
                            this.argument = argument;
                        }

                        get(): string {
                            return  `> ${this.argument}`;
                        }
                    }

                    const  notExportedVariable = 'hello';
                example.test.ts : |  #// テスト
                    import rewire from 'rewire';

                    // #focus: privateExample.__get__

                    test('rewire function', () => {
                        const privateExample = rewire('./example.ts');
                        const  notExportedFunction = privateExample.__get__('notExportedFunction');
                        expect(notExportedFunction('hello')).toBe('> hello');
                    });

                    test('rewire class', () => {
                        const  NotExportedClass = privateExample.__get__('NotExportedClass');
                        const  object = new NotExportedClass('hello');
                        expect(object.get()).toBe('> hello');
                    });

                    test('rewire variable', () => {
                        const  notExportedVariable = privateExample.__get__('notExportedVariable');
                        expect(notExportedVariable).toBe('hello');
                    });
                package.json : |  #// 起動コマンド
                    {
                        "scripts": {
                            "test": "ts-node node_modules/jest/bin/jest.js --watchAll",
                シェル : |  #// 起動コマンド
                    npm test
                参考: #ref: https://golang.hateblo.jp/entry/2021/03/12/214524
    環境変数, コマンドのパラメーター:
        Node.js:
            参照: process.env.__EnvironmentVariableName__  #// 未定義なら undefined
            設定: process.env.__EnvironmentVariableName__ = __Value__
            削除: delete  process.env.__EnvironmentVariableName__
            公式: https://nodejs.org/api/process.html#process_process_env
        process.argv:
        commander: #keyword: commander, Node.js parameters arguments  #// プログラム起動時のパラメーター
            インストール:
                npm install commander --save  #// @types/commander は不要です
            example.ts: |
                import * as commander from 'commander';

                commander.program.version('0.1.0')
                    .exitOverride(exitFromCommander)  #// デバッガー接続時に エラー メッセージ などを表示したいとき
                    .argument('<input-file>')  #// 必須の名前なし引数
                    .argument('[ouput-file]')  #// オプションの名前なし引数
                    .option("-l, --locale <s>")
                    .option("-t, --test")
                    .option("-d, --folder <>", "The root path of searching folder",  process.env.TYPRM_FOLDER)
                    .option("-n, --found-count-max <i>", "Max number of showing found lines in search",  process.env.TYPRM_FOUND_COUNT_MAX || main.foundCountMaxDefault)
                    .parse(process.argv);

                const  programArguments = commander.program.args;
                const  argument_1 = programArguments[0];

                const  programOptions = commander.program.opts();

                // エラー メッセージ など
                function  exitFromCommander(e: commander.CommanderError) {
                    if (e.code !== 'commander.version') {
                        console.log(e.message);
                    }
                }
            実行します:  #// メッセージを確認するときは、デバッガーに接続しないでください
                node build/app.js  --version
                node build/app.js  --help
                node build/app.js  arg1  --test  --found-count-max 1
ファイル: #keyword: JavaScript file,  Node.js file
    ファイル名: #// 文字列操作  #keyword: JavaScript path,  JavaScript file name
        フルパス:
            path.resolve >> カレント フォルダーを基準としてフルパスを返します:  #keyword: path.resolve
                import * as path from "path";  // or path = require("path")
                path.resolve(__RelativePath__);
        カレント フォルダー:  #keyword: js current folder directory
            process.cwd() >> カレント フォルダー のパスを返します:  #keyword: process.cwd
                const  currentFolder = process.cwd();
            process.chdir >> カレント フォルダーを変えます: |  #keyword: process.chdir finally
                const  currentFolder = process.cwd();
                try {
                    process.chdir(__NewCurrentFolderPath__);
                } finally {
                    process.chdir(currentFolder);
                }
            chdirInProject: #keyword:
                使用サンプル: |
                    test("____", async () => {
                        chdirInProject('src');
                定義サンプル: |
                    function  chdirInProject(relativePath: string) {
                        const  projectPath = path.dirname(__dirname);
                        process.chdir(projectPath);
                        process.chdir(relativePath);
                    }
                目的: jest を使う環境にて、テスト コード を実行開始するときの カレント フォルダー を揃えるため。
                    なお、無名関数を呼び出すときの カレント フォルダー は、
                    前回実行終了時の カレント フォルダー になっています。
        親フォルダー:  #keyword: JavaScript parent path
            path.parse:
                #search: path.parse
            path.dirname >> 親フォルダー:  #keyword: path.dirname
                サンプル コード:
                    import * as path from "path";  // or path = require("path")
                    path.dirname(__RelativePath__);
                補足:
                    path.dirname( '/path/to' )  === '/path'
                    path.dirname( '/path/to/' ) === '/path'
                    path.dirname( '/path' ) === '/'
                    path.dirname( '/' ) === '/'
        ファイル名:
            path.parse: | #keyword:
                path.parse( '/path/to.html' )  // {root: '/', dir: '/path', base: 'to.html', ext: '.html', name: 'to'}
                path.parse( 'path/to.html' )   // {root: '',  dir: '/path', base: 'to.html', ext: '.html', name: 'to'}
                path.parse( 'C:/a/to.html' )   // {root: '',  dir: 'C:/a',  base: 'to.html', ext: '.html', name: 'to'}
                path.parse( 'C:/to.html' )     // {root: '',  dir: 'C:',    base: 'to.html', ext: '.html', name: 'to'}
            path.basename:
                サンプル コード:
                    import * as path from "path";  // or path = require("path")
                    path.basename( '/path/to' ) === 'to'
                    path.basename( '/path/to/' ) === 'to'
                    path.basename( '/path' ) === '/'
                    path.basename( '/' ) === ''
                    path.basename( '' ) === ''
        拡張子:
            path.parse:
                #search: path.parse
            path.extname:
                サンプル コード:
                    import * as path from "path";  // or path = require("path")
                    path.basename( '/path/to.html' ) === '.html'
                    path.basename( '/path/to.tar.gz' ) === '.gz'
                    path.basename( '/path/to.' ) === '.'
                    path.basename( '/path/to' ) === ''
                    path.basename( '' ) === ''
            拡張子を変更します:
                サンプル コード: | #keyword: changeExtension
                    import * as path from 'path';
                    // changeExtension
                    // e.g. changeExtension("C:\folder\path.html", ".jpeg");  // "C:\folder\path.jpeg"
                    function  changeExtension(oldPath: string, newExtension: string): string {
                        const  parts = path.parse(oldPath);
                        return  parts.root + parts.dir +'/'+ parts.name + newExtension;
                    }
    カレント フォルダー: #search: js current folder directory
    ソース ファイル名: #// Node.js
        注意❗: src フォルダーにある TypeScript ファイルをビルドすると build フォルダーに移動するので、下記のパスは変わります
        __filename: ソース ファイル の フル パス
        __dirname:  ソース ファイル を含むフォルダーの フル パス
        ____.d.ts, 型定義ファイル:  #keyword: .d.ts, type definition file
            変数の宣言:
                export __Name__:
                    ____.d.cts:
                        書式: |
                            /// <reference types="node" />
                            export declare const __VariableName__: __Type__;
                        サンプル: |
                            /// <reference types="node" />
                            export declare const snapshots: {[key: string]: string};
                    ____.cjs:
                        書式: |
                            var  __Variable__ = __Value;
                            exports.__ExportingName__ = __Variable__;
                        サンプル: |
                            exports.snapshots = snapshots;
                export default: |
                    /// <reference types="node" />
                    declare var snapshots: {[key: string]: string};
                    export default snapshots;
            <reference types="node" />: #keyword:
                手動で .d.ts ファイルを作ったときに、.d.ts ファイルの先頭行に書きます。
                #ref: https://stackoverflow.com/questions/48216163/what-does-reference-types-node-mean
            参考: #ref: https://typescript-jp.gitbook.io/deep-dive/type-system/intro/d.ts
    ファイルの有無:  #keyword: JavaScript file folder directory exists
        ファイルまたはフォルダーがあるかどうか: |
            import fs from "fs";  // or fs = require("fs")  // file system
            const  exists = fs.existsSync('/the/path');
        フォルダーがあるかどうか: |
            import fs from "fs";  // or fs = require("fs")  // file system
            const  folderExists = fs.lstatSync('/the/path').isDirectory();
            // 注意: パスに * を含むとエラーになります
        ファイルがあるかどうか: |
            import fs from "fs";  // or fs = require("fs")  // file system
            const  fileExists = fs.lstatSync(targetFullPath).isFile();
            // 注意: パスに * を含むとエラーになります
        参考: https://stackoverflow.com/questions/4482686/check-synchronously-if-file-directory-exists-in-node-js/4482701
    ファイルの一覧:
        globby: #keyword:  #// グロブ・バイ と読みます。 Unix, Python の glob が由来らしい #ref: https://ja.wikipedia.org/wiki/グロブ
            使い方: カレント フォルダー に依存したりと使い方が難しいため、ファイルの一覧を作成する関数の中で globby を使います。
            インストール:
                npm install globby@11.0.4 --save  #// 2022-02 現在、version 12 ではビルドできない問題がるようです
            インポート:
                globby 11.0.4:
                    import globby from 'globby';
                    const  scanedPaths = await globby(['____']);
            サンプル:
                #ref: ${GitHub}/typrm/src/main.ts#function  listUpFilePaths
                #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts#function  listUpFiles
    ファイルのコピーや削除:
        フォルダーを作ります: |  #keyword: mkdirSync, JavaScript fs mkdirSync
            import * as fs from "fs";  // or fs = require("fs")  // file system
            fs.mkdirSync('__Path__', {recursive: true});
        フォルダーを削除します: |  #keyword: rmdirSync
            import * as fs from "fs";  // or fs = require("fs")  // file system
            fs.rmdirSync('__Path__', {recursive: true});
        コピーします:
            #search: copyFileSync
            #search: copyFolderSync
            #search: lib.ts
    ファイルの内容:
        #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#file
        全体をリードします: |  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#file_I_O
            - const  text: string = fs.readFileSync( "sample.txt",  "utf-8" );
            - const  text: Buffer = fs.readFileSync( "sample.txt" );
        1行ずつリードします:  #keyword: readline.createInterface, js file read
            #serach: readline.Interface, exampleReadStream
        ファイルの一部を置き換えます:  #keyword: JavaScript file replace  #search: lib.ts replaceFileSync
        文字列をファイルのようにリードします:  #keyword: JavaScript string file stream read
            サンプル: |  #// TypeScript
                import * as readline from 'readline';
                import { Readable } from 'stream';

                async function  tryStringReader() {

                    const stream = new Readable();
                    stream.push('line 1\nline 2\nline 3\n');
                    stream.push('line 4');
                    stream.push('line 4\nline 5');
                    stream.push(null);

                    const  reader = readline.createInterface({
                        input: stream,
                        crlfDelay: Infinity
                    });

                    for await (const line of reader) {
                        // if (breaking) {continue;}  // "reader" requests read all lines
                        console.log(`> ${line}`);
                    }
                }
                tryStringReader();
            参考:
                readline.Interface: #search: readline.Interface
                使っても大丈夫か: 大丈夫
                    #ref: https://stackoverflow.com/questions/12755997/how-to-create-streams-from-string-in-node-js
                    #// @TrentonD.Adams it appears that that comment is from the v10.x docs.
                    #// The v14.x docs simply say "The readable.push() method is used to push the content into the internal buffer"
                    #// which implies to me that it's a perfectly fine method to use.
        ファイルのように文字列にライトします:  #keyword: JavaScript string file stream write
            WritableMemoryStream: #keyword: WritableMemoryStream
            サンプル: |  #// TypeScript  #focus: WritableMemoryStream
                import * as readline from 'readline';
                import { Readable, Writable } from 'stream';

                async function  tryStringReader() {

                    const stream = new Readable();
                    stream.push('line 1\nline 2\nline 3\n');
                    stream.push('line 4');
                    stream.push('line 4\nline 5');
                    stream.push(null);

                    const  reader = readline.createInterface({
                        input: stream,
                        crlfDelay: Infinity
                    });
                    const  writer = new WritableMemoryStream();

                    for await (const line of reader) {
                        // if (breaking) {continue;}  // "reader" requests read all lines
                        writer.write(`${line}\n`);
                    }
                    console.log(`end: "${writer.toString()}"`);
                }

                class WritableMemoryStream extends Writable {
                    private array: string[];

                    constructor() {
                        super();
                        this.array = [];
                    }

                    _write(chunk: any, _encoding: BufferEncoding, callback: (error?: Error | null) => void) {
                        this.array.push(chunk);
                        callback();
                    }

                    toString(): string {
                        return this.array.join('');
                    }
                }

                tryStringReader();
        ストリーム: #search: Node.js Streams API
    圧縮:  #keyword: Node.js compressed file
        zlib.Gzip:  #keyword: Node.js zlib.Gzip
            サンプル: |  #// 圧縮します  #focus: gzip
                import * as zlib from 'zlib';
                import * as fs from 'fs';
                process.chdir(`${getHomePath()}/Desktop`);

                const reader = fs.createReadStream('src.txt');
                const writer = fs.createWriteStream('src.txt.gz');
                const gzip = zlib.createGzip();  // Gzip extends stream.Transform, Zlib

                reader.pipe(gzip).pipe(writer);
    パスワードのハッシュ関数:  #keyword: Node.js crypto hash
        公式: #ref: https://nodejs.org/api/crypto.html
        一覧: #// 使えるハッシュ関数の種類を一覧します
            コード (.ts):
                import * as crypto from 'crypto';
                console.log(crypto.getHashes().join(', '));  // 使える暗号の種類を一覧します
            出力: #// 2021-11-26 現在
                RSA-MD4, RSA-MD5, RSA-MDC2, RSA-RIPEMD160,
                RSA-SHA1, RSA-SHA1-2, RSA-SHA224, RSA-SHA256, RSA-SHA3-224, RSA-SHA3-256, RSA-SHA3-384,
                RSA-SHA3-512, RSA-SHA384, RSA-SHA512, RSA-SHA512/224, RSA-SHA512/256, RSA-SM3,
                blake2b512, blake2s256, id-rsassa-pkcs1-v1_5-with-sha3-224, id-rsassa-pkcs1-v1_5-with-sha3-256,
                id-rsassa-pkcs1-v1_5-with-sha3-384, id-rsassa-pkcs1-v1_5-with-sha3-512,
                md4, md4WithRSAEncryption, md5, md5-sha1, md5WithRSAEncryption, mdc2, mdc2WithRSA,
                ripemd, ripemd160, ripemd160WithRSA, rmd160, sha1, sha1WithRSAEncryption, sha224,
                sha224WithRSAEncryption, sha256, sha256WithRSAEncryption,
                sha3-224, sha3-256, sha3-384, sha3-512, sha384, sha384WithRSAEncryption,
                sha512, sha512-224, sha512-224WithRSAEncryption, sha512-256,
                sha512-256WithRSAEncryption, sha512WithRSAEncryption,
                shake128, shake256, sm3, sm3WithRSAEncryption, ssl3-md5, ssl3-sha1, whirlpool
        参考:
            パスワード: #search: password
            Node.jsで暗号化とハッシュ: #ref: https://qiita.com/_daisuke/items/990513e89ca169e9c4ad
    暗号化:  #keyword: Node.js crypto encrypt
        公式: #ref: https://nodejs.org/api/crypto.html
        サンプル: |
            import * as crypto from 'crypto';
            import * as fs from 'fs';
            process.chdir(`${getHomePath()}/Desktop`);

            const key = crypto.randomBytes(32);
            const iv = crypto.randomBytes(16);  // Initialization Vector

            const reader = fs.createReadStream('src.txt');
            const writer = fs.createWriteStream('src.txt.encrypted');
            const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(key), iv);
            reader.pipe(cipher).pipe(writer);
        参考:
            暗号: #search: crypto
            Node.jsで暗号化とハッシュ: #ref: https://qiita.com/_daisuke/items/990513e89ca169e9c4ad
ネットワーク, Ajax:  #keyword: JavaScript network
    ブラウザー, React など:
        fetch:  #search: HTTP fetch
    Node.js 単体:
        net: #keyword: Node.js net
            サンプル: |
                import * as net from 'net';  // const net = require('net');

                const client = net.connect(80, 'www.yahoo.co.jp');  // client: net.Socket extends stream.Duplex
                client.pipe(process.stdout);  // read
                client.once('connect', () => client.write('GET / HTTP/1.0\r\n\r\n'));  // write
            公式: #ref: https://nodejs.org/api/net.html
        request: #keyword: Node.js request  #// deprecated  #ref: https://www.npmjs.com/package/request
    Ajax: #keyword:
        GET: #search: cypress GET test_target_1.html
ストリーム:
    Web API >> Streams API: #keyword: Web API Streams API
        ReadableStream: #keyword:
            HTTP fetch response.text: #search: HTTP fetch example
                #ref: https://stackoverflow.com/questions/40385133/retrieve-data-from-a-readablestream-object
            #ref: https://developer.mozilla.org/ja/docs/Web/API/ReadableStream
    Node.js >> Steram: #keyword: Node.js Streams API
        公式: #ref: https://nodejs.org/api/stream.html
        reader.on, writer.write:
            書式: |
                reader.on('data', (buffer: string) => {writer.write(buffer);});
                reader.on('end', () => writer.end());
            サンプル (.ts): |  #// ファイルをコピーします  #focus: buffer, data, write, end
                import * as fs from "fs";
                process.chdir(`${getHomePath()}/Desktop`);
                const  readBufferSize = 15;

                const reader = fs.createReadStream('src.txt', { highWaterMark: readBufferSize });
                const writer = fs.createWriteStream('dest.txt');

                reader.on('data', (buffer: string) => {
                    console.log(`> ${buffer}`);
                    writer.write(buffer);
                });
                reader.on('end', () => writer.end());
                console.log('> end');
            src.txt: |
                a23456789
                b23456789
                c23456789
                d23456789
            サンプルの出力: |
                > end
                > a23456789
                b2345
                > 6789
                c23456789

                > d23456789
            補足:
                highWaterMark オプションを指定しない場合、64KB になります  #keyword: Node.js highWaterMark
                    #ref: https://stackoverflow.com/questions/27641571/changing-readstream-chunksize
        pipe:  #keyword: Node.js pipe
            書式: __Reader__.pipe(__Writer__);
            サンプル (.ts): |  #// ファイルをコピーします  #focus: pipe
                import * as fs from "fs";
                process.chdir(`${getHomePath()}/Desktop`);
                const  readBufferSize = 15;

                const reader = fs.createReadStream('src.txt', { highWaterMark: readBufferSize });
                const writer = fs.createWriteStream('dest.txt');

                reader.pipe(writer);
                console.log('> end');
            サンプルの出力: |
                > end
            補足:
                highWaterMark オプションを指定しない場合、64KB になります  #search: Node.js highWaterMark
        process.stdout:  #keyword: Node.js process.stdout
            サンプル (.ts): |  #// ファイルの内容を表示します  #focus: stdout
                import * as fs from "fs";
                process.chdir(`${getHomePath()}/Desktop`);
                const  readBufferSize = 15;

                const reader = fs.createReadStream('src.txt', { highWaterMark: readBufferSize });

                reader.pipe(process.stdout);
                console.log('> end');
            __Project__/.vscode/launch.json:
                "outputCapture": "std"  #search: VSCode outputCapture
            サンプルの出力: |
                > end
                （ファイルの内容）
        childProcess.stdout:  #keyword: Node.js childProcess.stdout
            サンプル (.ts): |  #// 子プロセスの出力を親プロセスの出力に転送します  #focus: stdout  #keyword: Node.js childProcess example
                import * as child_process from 'child_process';
                const  scriptPath = '../build/app.js';

                const  childProcess = child_process.exec(`node ${scriptPath}`);
                if (childProcess && childProcess.stdout) {
                    childProcess.stdout.pipe(process.stdout);
                    console.log('> end');
                }
            __Project__/.vscode/launch.json:
                "outputCapture": "std"  #search: VSCode outputCapture
            サンプルの出力: |
                > end
                （子プロセスの出力）
        child_process.exec:  #keyword: Node.js child_process.exec
            サンプル (.ts): #keyword: Node.js childProcess example
            timeout オプション: プロセスの寿命  #keyword: Node.js child_process.exec timeout
        stream.Duplex:  #// ReadableStream と WritableStream
            net: #search: Node.js net
        stream.Transform:
            zlib.Gzip: #search:
            Crypt:
        readline.Interface: #keyword:
            LF CR+LF 混合や BOM にも対応したテキストをリードする場合: |  #keyword: JavaScript read line
                const  fileContents = fs.readFileSync(inputFilePath, 'utf-8');
                const  hasLastLF = (fileContents.slice(-1) === '\n');
                const  lines: string[] = fileContents.split('\n');
                if (hasLastLF) {
                    lines.pop();  // cut last empty line
                }
            テキスト ファイル の場合の一般的な方法: |  #// これでリード・ライトすると LF に統一されてしまうので注意  #focus: reader, filePath
                import * as readline from 'readline';

                const  reader = readline.createInterface({
                    input: fs.createReadStream(filePath),
                    crlfDelay: Infinity
                });
            文字列の場合:
                Readable.from: |
                    const stream = Readable.from('line 1\nline 2\nline 3\n');
                Readable: |  #focus: reader, stream
                    import * as readline from 'readline';
                    import { Readable } from 'stream';

                    const stream = new Readable();
                    stream.push('line 1\nline 2\nline 3\n');
                    stream.push('line 4');
                    stream.push('line 4\nline 5');
                    stream.push(null);

                    const  reader = readline.createInterface({
                        input: stream,
                        crlfDelay: Infinity
                    });
            参考:
                文字列をファイルのようにリードします:  #search: JavaScript string file stream
        非推奨:
            memorystream: #keyword: npm memorystream
                注意: メンテナンスされていないらしい  #ref: https://blog.lufia.org/entry/2021/09/26/113000
                公式: #ref: https://www.npmjs.com/package/memorystream
                インストール: npm install memorystream
JSON:  #keyword:
    JSON:
        変換します:
            const  jsonTree = JSON.stringify(flatJSON, null, '    ');
            #search: JSON.stringify
        コメント:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#operation
            JSON: |
                "//": "コメントです"
            Hjson: #keyword:  #ref: https://hjson.github.io/
                # コメントです
                // コメントです
                /* コメントです */
        JSON をソートして整形します: #keyword: sort-json
            Python + VSCode:  #keyword: sort JSON Python
                Python をインストールします: #search: install Python Visual Studio Code
                ~/_out.json ファイルに整形前の JSON を保存します:
                    bash: |
                        code ~/_out.json
                整形したデータを ~/_out.json ファイルに出力します:
                    bash: |  #// インデントは削除してください
                        pushd ${HOME}
                        python -c "
                        import json
                        data_dictionary = json.load(open('_out.json', 'r')) 
                        print(json.dumps(data_dictionary, indent=4, sort_keys=True))" > ~/_out_sorted.json
                        code ~/_out_sorted.json
                        popd
                作業ファイルを削除します:
                    bash: |
                        rm ~/_out_sorted.json
                        rm ~/_out.json
                参考: #ref: https://docs.python.org/ja/3/library/json.html
            sort_json:  #keyword: sort_json
                #ref: ${GitHub}/sort_json/sort_json.bat
        JSON を整形します:  #keyword: format-json
            Linux Python + VSCode:
                Python をインストールします: #search: install Python Visual Studio Code
                ~/_out.json ファイルに整形前の JSON を保存します:
                    Linux bash: |
                        code ~/_out.json
                整形したデータを _out.json ファイルに出力します:
                    Linux bash:
                        下記インデントは削除してください: |
                            pushd ${HOME}
                            python -c "
                            import json
                            data_dictionary = json.load(open('_out.json', 'r')) 
                            print(json.dumps(data_dictionary, indent=4, sort_keys=False))" > ~/_out_formated.json
                            code ~/_out_formated.json
                            popd
                作業ファイルを削除します:
                    bash: |
                        rm ~/_out_formated.json
                        rm ~/_out.json
            Windows:
                format_json:  #keyword: format_json Windows  #ref: ${GitHub}/format_json/format_json.bat
            JavaScript:
                JSON.stringify: #keyword: JSON.stringify (stringfy ではない)
                    const  jsonTree = JSON.stringify(flatJSON, null, '    ');
        JSON を見やすく表示します: #ref: http://marianoguerra.github.io/json.human.js/
            #// 通信はしていないようです（開発者ツールのネットワークのログより）
        MessagePack から JSON に変換します:  #keyword: MessagePack JSON
            (@CentOS7):
                msgpack-python をインストールします: 
                    pip install  msgpack-python
                _out.pack ファイルに MessagePack 形式のデータを保存します:
                _out.pack ファイルから JSON に変換したデータを _out.json ファイルに出力します: |  #// インデントは削除してください
                    python -c "
                    import msgpack, json
                    for message in msgpack.Unpacker(open('_out.pack', 'rb'), raw=False):
                        print(json.dumps(message, indent=4, sort_keys=False))" > _out.json
                    rm _out.pack
            参考:
                MessagePackを使ったデータ分析のすすめ: #ref: https://qiita.com/m_mizutani/items/c40295549c3368a4257d
        文字列リテラルの中の JSON を展開します:  #keyword: unescape-json, unescape_json  #ref: ${GitHub}/unescape_json/unescape_json.bat
    JSON から YAML に変換します:  #search: JSON to YAML, json2yaml
    JSON スキーマ: #keyword: JSON schema
        参考:
            公式:  #ref: https://json-schema.org/
            JSON Schemaのすゝめ:  #ref: https://qiita.com/g0e/items/9a4f886897fd46f107a8
            JSON スキーマの JSON スキーマ:  #ref: http://json-schema.org/draft-07/schema#
        お試しサイト: #keyword: jsonschemavalidator.net  #ref: https://www.jsonschemavalidator.net/
        基本のサンプル: #keyword: JSON schema properties
            #// object 型、文字列型の name プロパティ、数値型の level プロパティ
            schema: |  #focus: object, name, level  #keyword: JSON schema basic example
                {
                    "type": "object",
                    "properties": {
                        "name": {
                            "type": "string"
                        },
                        "level": {
                            "type": "number"
                        }
                    }
                }
            validation 結果: |  #search: jsonschemavalidator.net
                {"name": "taro", "level": 1}     // OK. 完全一致
                {"name": "taro"}                 // OK. プロパティが不足しても OK
                {"name": "taro", "hoge": 12345}  // OK. 他のプロパティが追加されても OK
                {"name": 123, "level": "lv1"}    // NG. 型が異なるため
        必須と追加:  #// required, additionalProperties
            required:  #// 必須プロパティ  #keyword: JSON schema required
                schema: |  #focus: required
                    {
                        "type": "object",
                        "required": ["name", "level"],
                    省略部分は: #search: JSON schema basic example
                validation 結果: |
                    {"name": "taro", "level": 1}     // OK
                    {"name": "taro"}                 // NG
            additionalProperties:  #// 他のプロパティが追加されても OK かどうか  #keyword: JSON schema additionalProperties
                schema: |  #focus: additionalProperties  #search: JSON schema basic example
                    {
                        "type": "object",
                        "additionalProperties": false,
                    省略部分は: #search: JSON schema basic example
                validation 結果: |
                    {"name": "taro", "level": 1}     // OK
                    {"name": "taro", "hoge": 12345}  // NG
        値の範囲:  #// pattern, minLength, maxLength, enum
            文字列:  #keyword: JSON schema pattern minLength maxLength
                schema: |  #focus: pattern, minLength, maxLength
                    {
                        "type": "object",
                        "properties": {
                            "name": {
                                "type": "string",
                                "pattern": "^[a-zA-Z0-9]+$",
                                "minLength": 3,
                                "maxLength": 16
                    省略部分は: #search: JSON schema basic example
                validation 結果: |
                    {"name": "taro", "level": 1}  // OK
                    {"name": "ta",   "level": 1}  // NG. 短すぎる
            選択（文字列）:  #keyword: JSON schema enum
                schema: |  #focus: enum
                    {
                        "type": "object",
                        "properties": {
                            "name": {
                                "type": "string",
                                "enum": ["taro", "jiro"]
                    省略部分は: #search: JSON schema basic example
                validation 結果: |
                    {"name": "taro", "level": 1}  // OK
                    {"name": "sabu", "level": 1}  // NG
        配列:  #// array, minItems, maxItems
            基本のサンプル: #keyword: JSON schema array
                schema: |  #focus: array, items
                    {
                        "type": "object",
                        "properties": {
                            "name": {
                                "type": "array",
                                "items": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                validation 結果: |  #search: jsonschemavalidator.net
                    {"name": ["taro", "jiro"]}  // OK
                    {"name": []}   // OK
                    {"name": [1]}  // NG
            要素数:  #keyword: JSON schema minItems maxItems
                schema: |  #focus: minItems, maxItems
                    {
                        "type": "array",
                        "minItems": 1,
                        "maxItems": 2,
                validation 結果: |
                    {"name": ["taro"]}   // OK
                    {"name": []}         // NG
                    {"name": ["taro", "jiro", ""]}  // NG
        依存関係:  #// dependencies, oneOf  #// あるプロパティの値と別のプロパティの値の間の条件
            基本のサンプル: #keyword: JSON schema dependencies oneOf
                schema: |  #focus: dependencies, job
                    {
                        "type": "object",
                        "properties": {
                            "job": {
                                "type": "string",
                                "enum": ["manager", "employee"]
                            },
                            "allow": {  // ここになくてもよい
                                "type": "string"
                            }
                        },
                        "dependencies": {
                            "job": {  // 条件式（入力値）に含めるプロパティ名
                                "oneOf": [  // どれか１つに一致するという条件
                                    {
                                        "properties": {
                                            "job": {  // 条件式（dependencies の直下に指定したプロパティであるため）
                                                "enum": ["manager"] 
                                            },
                                            "allow": {  // プロパティの定義（バリデーションの内容）
                                                "enum": ["approval", "reject"]
                                            }
                                        }
                                    },
                                    {
                                        "properties": {
                                            "job": {
                                                "enum": ["employee"] 
                                            },
                                            "allow": {
                                                "enum": ["request", "rest"]
                                            }
                                        }
                                    }
                                ]
                            }
                        }
                    }
                validation 結果: |
                    {"job": "manager", "allow": "approval"}   // OK
                    {"job": "manager", "allow": "rest"}       // NG
        設定の参照:  #// definitions, $ref  #// 型定義  #keyword: JSON schema definitions $ref
            schema: |  #focus: name, $ref, definitions
                {
                    "type": "object",
                    "properties": {
                        "owner": {
                            "$ref": "#/definitions/name" 
                        },
                        "partner": {
                            "$ref": "#/definitions/name" 
                        },
                    },
                    "definitions": {  // definitions である必要はありません
                        "name": {
                            "type": "string",
                            "pattern": "^[a-zA-Z0-9]+$",
                            "minLength": 3,
                            "maxLength": 16
                        }
                    }
                }
            validation 結果: |  #search: jsonschemavalidator.net
                {"owner": "taro", "partner": "jiro"}   // OK
                {"owner": "taro", "partner": "ji_ro"}  // NG
                {"owner": "ta_ro", "partner": "jiro"}  // NG
YAML:  #// https://yaml.org  #search: steps.yaml  #keyword:
    文法:
        シーケンス: #ref: https://yaml.org/spec/1.2.2/#21-collections
        マッピング:
    Node.js 用パーサー >> js-yaml:
        インストール: npm install js-yaml --save
        サンプル コード:
            const  text = fs.readFileSync(filename);
            return yaml.load(text);
    JSON から YAML に変換します:  #keyword: JSON to YAML
        DevToys:  #search: DevToys
        json2yaml:  #keyword: json2yaml
            インストールします:
                #Git bash
                - mkdir -p ~/bin/json2yaml
                - cd       ~/bin/json2yaml
                - npm install json2yaml
            変換します:
                #Git bash
                - cd  ~/bin/json2yaml
                - tee  target.json  #// JSON をコピペして Ctrl + C キーを押します
                    #// または start . でフォルダーを開いて target.json を編集します

                - ./node_modules/.bin/json2yaml target.json > target.yaml
                - cat  target.yaml  #// YAML を表示します
        Python:  #keyword: PyYAML
            (@CentOS7):
                msgpack-python をインストールします: 
                    pip install  msgpack-python  PyYAML
                _out.pack ファイルに MessagePack 形式のデータを保存します:
                _out.pack ファイルから YAML に変換したデータを _out.yaml ファイルに出力します: |  #// インデントは削除してください
                    pip install  msgpack-python  PyYAML
                    python -c "
                    import msgpack, yaml
                    for message in msgpack.Unpacker(open('_out.pack', 'rb'), raw=False):
                        print(yaml.dump(message, sort_keys=False))"
    YAML Front Matter, gray-matter: #keyword:  #ref: https://github.com/jonschlinkert/gray-matter
        概要: --- から始まるファイルに、YAML 形式でコンテンツのメタデータを書き、
            次の --- の行の下に HTML や　Markdown など任意のコンテンツを書きます。
        サンプル: |
            ---
            title: Hello
            slug: home
            ---
            <h1>Hello world!</h1>
        解析後のサンプル:
            {
                content: '<h1>Hello world!</h1>',
                data: { 
                    title: 'Hello', 
                    slug: 'home' 
                }
            }
        参考: #search: Next.js getStaticProps
CSV:  #keyword: JavaScript CSV
    配列からCSV 文字列へ:
        簡易版: values.join(', ')  #// 値にコンマがあると正しくありません
    CSV 文字列から配列へ:
        #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#CSV
    CSV ファイルをパースします: |
        import * as fs from 'fs';
        import * as csvParse from 'csv-parse';

        async function load(csvFilePath: string): Promise<void> {
            const  table: string[] = [];
            const  promise = new Promise<void>((resolveFunction, _rejectFunction) => {

                fs.createReadStream(csvFilePath)
                    .pipe(
                        csvParse({ quote: '"', ltrim: true, rtrim: true, delimiter: ',', relax_column_count: true }))
                    .on('data',
                        (columns) => {
                            table.push(columns);
                        })
                    .on('end', () => {
                        resolveFunction();
                    });
            });
            return  promise;
        }
    トラブル シューティング(CSV):
        - #// CSV_INCONSISTENT_RECORD_LENGTH
            手順: csvParse
            エラー: |
                CSV_INCONSISTENT_RECORD_LENGTH 例外
            対策:
                relax_column_count を true にします: |
                    csvParse({ ___, relax_column_count: true })
クリップボード:  #keyword: Node.js JavaScript npm clipboard
    ローカル用:
        clipboardy:  #// https://github.com/sindresorhus/clipboardy  #keyword:
            サンプル: |
                import * as clipboardy from 'clipboardy';

                function  main() {
                    clipboardy.writeSync('🦄');
                    var d = clipboardy.readSync();
                    d = d;
                }
                main();
            対応: macOS, Windows, Linux, OpenBSD, FreeBSD, Android with Termux, and modern browsers.
            セキュリティ調査結果:
                exe ファイル:
                    内部で clipboard_x86_64.exe などの実行ファイルを呼び出していますが、
                    実行ファイルはウィルス対策ソフトが監視しているので安全です。
                    __Project__/node_modules/clipboady/fallbacks フォルダー内にあります。
                JavaScript ファイル:
                    コード自体は単にプロセス呼び出しをしているだけです。
                    package.json の dependencies にある arch, execa, is-wsl
                arch:  #keyword:
                    OSを判定します。
                    アーチと呼びます。
                    https://www.npmjs.com/package/arch
                execa:  #keyword: 
                    子プロセスを起動します。child_process の改良版。
                    https://www.npmjs.com/package/execa
                is-wsl:  #keyword:
                    WSL (Windows Subsystem for Linux) のユーティリティ
                    https://www.npmjs.com/package/is-wsl
        system call:  #// https://stackoverflow.com/questions/7778539/copy-to-clipboard-in-node-js
        clipboard-event:  #// https://stackoverflow.com/questions/63952819/how-to-detect-the-changes-of-system-clipboard-with-nodejs
    ブラウザー用:
        clipboard :  #// https://www.npmjs.com/package/clipboard
            ブラウザーが必要です:  #// https://stackoverflow.com/questions/38255661/errors-with-clipboard-js-in-react-component
        clipboard-polyfill:  #// https://github.com/lgarron/clipboard-polyfill
            ブラウザーが必要です:
        copy-to-clipboard :  #// https://www.npmjs.com/package/copy-to-clipboard
            ブラウザーが必要です:
        clipboard-copy:  #// https://co.bsnws.net/article/303
            ブラウザーが必要です:
画像: #keyword: Node.js JavaScript image
    sharp: #keyword: Node.js JavaScript sharp  #ref: https://sharp.pixelplumbing.com
        プロジェクト: #keyword: sharp project
            処理手順: #keyword: sharp project steps
                プロジェクトを VSCode で開きます:
                    #ref: ${GitHub}/MyPrivateCode/image_sharp
                _input フォルダーに入力画像ファイルをコピーします:
                    #ref: ${GitHub}/MyPrivateCode/image_sharp/_input
                コードを編集します:
                    #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts
                処理を実行します:
                    F5 キー
                _output フォルダーに出力画像ファイルができます:
                    #ref: ${GitHub}/MyPrivateCode/image_sharp/_output
            トリミング: #keyword: sharp trimming
                処理手順: #search: sharp project steps
                サンプル コード: |  #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts#function  trimming
                    async function  trimming() {
                        const  files = await listUpFiles('../_input', '../_output');
                        fs.mkdirSync('../_output', {recursive: true});
                        for (const file of files) {

                            sharp(file.inputFilePath)
                                .extract({
                                    left:   100,
                                    top:    100,
                                    width:  100,
                                    height: 100 })
                                .toFile(file.outputFilePath);
                        }
                    }
                座標: #search: mac image width height size
            薄くする: #keyword: image 薄くする,  明るくする brightness
                処理手順: #search: sharp project steps
                linear: |  #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts#function  linear
                    sharp(file.inputFilePath)
                        .linear(0.5, 128)
                        .toFile(file.outputFilePath);
                iPhone で試す:  #// linear はありません
                    写真アプリに転送
                brightness: |  #ref: ${GitHub}/MyPrivateCode/image_sharp/src/sharp.ts#function  brightness
                    sharp(file.inputFilePath)
                        .modulate({
                            brightness:1.3,
                        })
                        .toFile(file.outputFilePath);
        プロジェクトに入っていない処理:
            リサイズ, 幅高さ:  #keyword: Node.js sharp resize
                サンプル: |  #focus: resize  #search: sharp project
                    const  imageChain = sharp(inputFilePath);
                    const  resizedImageChain = imageChain.resize( 100, 100, {fit: 'contain', background: {r:0,g:0,b:0,alpha:0}} );
                        // cover:   [ image [ buffer ] ]  (defalut) The buffer has a part of image
                        // contain: [ buffer [ image ] ]  The part of buffer has the image
                    const  image = await imageChain.metadata();
                    const  resizedImage = await resizedImageChain.toBuffer({ resolveWithObject: true });
                    resizedImageChain.toFile(outputFilePath);

                    console.log(image.width, image.height);
                    console.log(resizedImage.info.width, resizedImage.info.height);
                サンプルの説明:
                    - resize メソッドでリサイズします
                    - metadata メソッドはリサイズ前の幅高さなどを返します
                    - toBuffer メソッドに resolveWithObject:true を指定するとリサイズ前の幅高さなどを返します
        コーディングしていない処理:
            ぼかし: #ref: https://blog.kozakana.net/2019/04/sharp-image-operations/
        参考:
            #ref: https://note.affi-sapo-sv.com/nodejs-sharp.php
            #ref: https://blog.kozakana.net/2019/04/sharp-image-processing/
        インストール:
            bash:
                npm install sharp @types/sharp --save
            __Project__/tsconfig.json: |
                {
                    "compilerOptions": {
                        "allowSyntheticDefaultImports": true,
            main.ts: |
                import sharp from 'sharp';

                main();
                async function  main() {
                    sharp('../test/image.png')
                        .extract({ left: 0, top: 0, width: 100, height: 100 })
                        .toFile('./_output.png');
                }
            sharp for Windows をインストールできない:
                Stack overflow: #ref: https://stackoverflow.com/questions/71301821/cant-install-sharp-on-windows-10-x64
                sharp 公式より:  #ref: https://github.com/lovell/sharp/issues?q=is%3Aissue+windows+install
                    v0.30.2 で解決しそう: #ref: https://github.com/lovell/sharp/issues/3086
                    sharp@0.29.3 でも良さそう: #ref: https://github.com/lovell/sharp/issues/3086
npm:  #keyword: npm, Node.js
    公式:
        API: #ref: https://nodejs.org/api/
    設定ファイル:  #glossary:
        package.json: #// 使うパッケージの設定
            script:
                npm-scripts:  #keyword:
                    OSやシェルの違いを吸収します:  #search: run-script-os
        package-lock.json: #// 依存するパッケージも含めた全設定
    Node.js プロジェクト:  #keyword: Node.js projects
        try_JestOfConsole:  #keyword:  #// コンソール アプリケーション, Jest あり
            使い方:  #// Windows, mac  #keyword: Node.js project usage
                try_JestOfConsole プロジェクトのフォルダーをコピーします:
                    #ref: ${GitHub}/Trials/try_JestOfConsole
                フォルダー名を新しいプロジェク名に変えます:
                Visual Studio Code で新しいプロジェクトのフォルダーを開きます: #copy: open VSCode
                    Visual Studio Code を右クリック（Windows の タスク バー または mac の Dock）>>
                    New Window >> プロジェクト フォルダー を Visual Studio Code へドラッグ＆ドロップします
                一部のファイル名をコマンド名に変えます:
                    __Project__/src/app_test.ts:  app をコマンド名に改名します
                    __Project__/src/app.ts:       app をコマンド名に改名します
                一部のファイルの中にあるコマンド名を変えます:
                    __Project__/.vscode/launch.json: |  #// 下記 app をコマンド名に改名します
                        "program": "${workspaceFolder}/src/app_test.ts",
                node_modules フォルダーを復活させます:
                    VSCode >> Terminal（メニュー）>> New Terminal >>
                    npm ci
                Jest のウォッチモードを起動して Visual Studio Code と接続してテストを実行します:  #serach: VSCode Jest command
        try_TypeScript_Node_js:  #keyword:  #// コンソール アプリケーション, Jest なし
            プロジェクト: #ref: ${GitHub}/Trials/try_TypeScript_Node_js
            使い方:
                try_TypeScript_Node_js プロジェクトのフォルダーをコピーします:
                フォルダー名を新しいプロジェク名に変えます:
                Visual Studio Code で新しいプロジェクトのフォルダーを開きます: #copy: open VSCode
                    Visual Studio Code を右クリック（Windows の タスク バー または mac の Dock）>>
                    New Window >> プロジェクト フォルダー を Visual Studio Code へドラッグ＆ドロップします
                node_modules フォルダーを復活させます:
                    VSCode >> Terminal（メニュー）>> New Terminal >>
                    npm ci
                試しに動かす場合:
                    プログラムを起動します:
                        F5 キーを押します
                            #// __Project__/src/main_test.ts と __Project__/src/main.ts を実行します
                    試しに動かすコードを貼り付けます:
                        __Project__/src/app_test.ts >> main の前
                コマンドにする場合:
                    一部のファイル名をコマンド名に変えます:
                        __Project__/src/app_test.ts:  app をコマンド名に改名します
                        __Project__/src/app.ts:       app をコマンド名に改名します
                    一部のファイルの中にあるコマンド名を変えます:
                        __Project__/.vscode/launch.json: |  #focus: app  #// 下記 app をコマンド名に改名します
                            "program": "${workspaceFolder}/src/app_test.ts",
                        __Project__/src/app_test.ts: |
                            const  scriptPath = '../build/app.js';
                        __Project__/__app__.bat: |
                            "node ./build/app.js"
                        __Project__/__app__.command: |
                            # chmod +x __app__.command
                            node ${this_folder}/build/app.js
                    一部のファイルを削除します:
                        __Project__/steps.yaml
    インストール, 手順:  #keyword: install Node.js,  Sinstall npm TypeScript JavaScript Node.js VSCode
        Node.js プロジェクト:  #search: Node.js projects
        Windows に Node.js だけインストールします:  #search: install Node.js
        Windows に Node.js と Visual Studio Code をインストールします:  #// Jest なし  #keyword: VSCode Node.js
            Node.js projects:  #search: Node.js projects
            Node.js プロジェクトをインストールします:  #// 開発環境なし
                Node.js をインストールします:
                プロジェクトをコピーします:
                シェル:
                    npm install --only=production
                    npm start
            Windows に Node.js と Visual Studio Code をインストールします:  #// Jest なし
                プロジェクトを作る場合:
                    Node.js をインストールします:  #keyword: install Node.js for Windows
                        - https://nodejs.org/ja/download/ >> Windows Installer (.msi) >> 64-bit
                        - ダウンロードしたファイル（例：node-v14.15.0-x64.exe）を開きます
                        - インストール オプションはデフォルトを使用
                        - プロキシがある LAN に Windows がある場合:
                            プロキシの設定をします:
                                - Windows スタート >> PowerShell
                                - npm config -g set proxy "http://___.___.___.___:____"
                                - npm config -g set https-proxy "http://___.___.___.___:____"
                            （不要になったら）プロキシの設定を解除します:
                                - npm config -g rm proxy
                                - npm config -g rm https-proxy
                    Visual Studio Code をインストールします:
                        - https://code.visualstudio.com/
                        - ダウンロードしたファイル（例：VSCodeUserSetup-x64-1.55.2.exe）を開きます
                        - インストール オプションはデフォルトを使用
                        - （推奨）VSCode (Visual Studio Code をタスクバーにピン止めします:
                        - （推奨）Ctrl + S キーを押したときに全てのファイルを保存するように設定します: |
                            VSCode >> File >> Preferences >> Keyboard Shortcuts >> save all （と入力） >>
                                File: Save All （をダブルクリック） >> Ctrl + S キー >> Enter キー
                    プロジェクトを新規作成します:
                        Visual Studio Code で新しいフォルダー try_node_js を開きます:  #template: __Project__
                            VSCode >> File >> Open Folder >> デスクトップ >> 新しいフォルダー >> try_node_js >> フォルダーの選択  #template: __Project__
                        __Project__/package.json :
                            npm コマンドを使う場合:
                                Terminal:  #// VSCode >> Terminal >> New Terminal
                                    npm init -y
                            npm コマンドを使ったときの内容: |
                                {
                                    "name": "__FolderName__",
                                    "version": "1.0.0",
                                    "description": "",
                                    "main": "index.js",
                                    "scripts": {
                                        "test": "echo \"Error: no test specified\" && exit 1"
                                    },
                                    "keywords": [],
                                    "author": "",
                                    "license": "ISC"
                                }
                            独自の内容:
                                __Project__/package.json : |  #// VSCode の EXPLORER（の中を右クリック）>> New File >> package.json
                                    {
                                        "name": "__FolderName__",
                                        "version": "0.0.1",
                                        "description": "",
                                        "scripts": {
                                            "setup": "npm ci",
                                            "clean": "powershell rm -r -fo node_modules"
                                        },
                                        "author": "",
                                        "license": "ISC",
                                        "private": false,
                                        "dependencies": {},
                                        "devDependencies": {}
                                    }
                                #// ファイルを保存します
                    依存する Node.js モジュールをインストールします:  #// サンプルとして Swagger UI をインストールします
                        Terminal:  #// VSCode >> Terminal >> New Terminal
                            npm install swagger-ui-dist  #// 開発用モジュールの場合は --save-dev も付ける
            既存のプロジェクトを使う場合:
                #serach: Node.js projects
            古い手順:
                Node.js をインストールします:
                    - https://nodejs.org/ja/download/ >> Windows Installer (.msi) >> 64-bit
                    - ダウンロードしたファイル（例：node-v14.15.0-x64.exe）を開きます
                    - インストール オプションはデフォルトを使用
                    - プロキシがある LAN に Windows がある場合:
                        - Windows スタート >> PowerShell
                        - npm config -g set proxy "http://___.___.___.___:____"
                        - npm config -g set https-proxy "http://___.___.___.___:____"
                __Application__ が使う Node.js パッケージをインストールします:
                    - Windows スタート >> PowerShell
                    - npm install -g  __Package__
                実行するときは、NODE_PATH を設定します:
                    set NODE_PATH=%USERPROFILE%\AppData\Roaming\npm\node_modules
                    node  ____.js
        Windows に Node.js と Jest と Visual Studio Code をインストールします:  #keyword: install VSCode Node.js Jest
            #// Jest の watch を使って VSCode のデバッガーを爆速で起動する
            #// Jest の詳細については、Test.yaml を参照
            設定: #settings:
                __JestProject__: try_jest
            Node.js をインストールします:
                - https://nodejs.org/ja/download/ >> Windows Installer (.msi) >> 64-bit
                - ダウンロードしたファイル（例：node-v14.16.1-x64.msi）を開きます
                - インストール オプションはデフォルトを使用
                - プロキシがある LAN に Windows がある場合:
                    - Windows スタート >> PowerShell
                    - npm config -g set proxy       "http://___.___.___.___:____"
                    - npm config -g set https-proxy "http://___.___.___.___:____"
            Visual Studio Code をインストールします:
                - https://code.visualstudio.com/
                - ダウンロードしたファイル（例：VSCodeUserSetup-x64-1.55.2.exe）を開きます
                - インストール オプションはデフォルトを使用
                - （推奨）VSCode (Visual Studio Code をタスクバーにピン止めします:
                - （推奨）Ctrl + S キーを押したときに全てのファイルを保存するように設定します: |
                    VSCode >> File >> Preferences >> Keyboard Shortcuts >> save all （と入力） >>
                        File: Save All （をダブルクリック） >> Ctrl + S キー >> Enter キー
            既存のプロジェクトを使う場合:
                #serach: try_JestOfConsole
            既存のプロジェクトを使わない場合:
                プロジェクトを新規作成します:
                    Visual Studio Code で新しいフォルダー try_jest を開きます:  #template: __JestProject__
                        VSCode >> File >> Open Folder（macの場合 Open）>> デスクトップ >> 新しいフォルダー >> try_jest >> フォルダーの選択  #template: __JestProject__
                    __Project__/package.json : |  #// VSCode の EXPLORER（の中を右クリック）>> New File >> package.json
                        {
                            "name": "try_jest",
                            "version": "0.0.1",
                            "description": "",
                            "scripts": {
                                "setup": "npm ci",
                                "test":  "jest --watchAll",
                                "clean": "powershell rm -r -fo node_modules"
                            },
                            "author": "",
                            "license": "ISC",
                            "private": false,
                            "dependencies": {},
                            "devDependencies": {},
                            "jest": {
                                "roots": [
                                    "<rootDir>/src"
                                ],
                                "testMatch": [
                                    "**/__tests__/**/*.+(ts|tsx|js)",
                                    "**/?(*.)+(spec|test).+(ts|tsx|js)"
                                ],
                                "transform": {
                                    "^.+\\.(ts|tsx)$": "ts-jest"
                                },
                                "maxWorkers": 1
                            }
                        }
                        #// ファイルを保存します
                    （メモ）:  #keyword: VSCode jest --watchAll
                        jest --watchAll を ts-node node_modules/jest/bin/jest.js --watchAll にすると、
                        jest の f ボタンによる再テストをしたときにターミナルの表示がクリアされません。
                    必要な Node モジュールをインストールします:
                        Terminal:  #// VSCode >> Terminal >> New Terminal
                            npm install  typescript  ts-node  @types/node  jest  ts-jest  @types/jest  --save-dev
                    __Project__/tsconfig.json : |
                        {
                            "compilerOptions": {
                                "declaration": true,
                                "strict": true,
                                "lib": [ "es2015", "dom" ],
                                "inlineSourceMap": true,
                                "inlineSources": true,
                                "outDir": "build"
                            }
                        }
                    __Project__/src/lib.ts : |
                        export function  add(a: number, b: number): number {
                            return  a + b;
                        }
                    __Project__/src/lib.test.ts : |
                        import { add } from './lib';

                        test('add', () => {
                            const  a = 2;
                            const  b = 3;
                            const  answer = 5;

                            const  result = add( a, b );
                            expect(result).toBe(answer);
                        });
                    Jest のウォッチモードを起動して Visual Studio Code と接続します:  #keyword: VSCode Jest command
                        メニュー:
                            Windows: |
                                Terminal >> 1: powershell（Terminal の上）>> Create JavaScript Debug Terminal
                            mac: |
                                Terminal >> 1: zsh（Terminal の上）>> Create JavaScript Debug Terminal
                        Terminal:
                            npm test  #// package.json#scripts/test  #keyword: npm test
                        #// テストが実行され、テストがパスし、Jest の watch のメニューが表示されます
                    デバッガーに接続して失敗したテストをデバッグします:
                        テストが失敗するコードにしてみます:
                            __Project__/src/lib.ts :
                                変更前: a + b
                                変更後: a + a
                            #// 保存するとテストが自動的に開始され、テストに失敗します
                        ブレークポイントを張ります:
                            たとえば __Project__/src/lib.test.ts の add 関数を呼び出すコードに張ります:
                        Terminal:
                            - Terminal をクリックしてアクティブにします
                            - f キーを押します
                            #// ブレークポイントでブレークします
                            #// F10 キーで ステップ オーバー、F11 キーで ステップ イン します
                    テストを再起動します:
                        プログラムがブレーク中のとき:
                            Continue ボタン:
                                #// Jest の watch のメニューが Terminal に表示されます
                            Terminal:
                                - Terminal をクリックしてアクティブにします
                                - f キーを押します
                        プログラムが実行中で終わらないとき、Jest の watch のメニューが表示されないとき:
                            Terminal タブ（下）>> ゴミ箱アイコン（右）:
                            メニュー: |
                                Terminal >> 1: powershell（Terminal の上）>> Create JavaScript Debug Terminal
                            Terminal:
                                npm test  #// package.json#scripts/test
                    １つのテストのみ実行します:
                        テストするテストコードがあるファイルを限定します:
                            Jest watch >> p >> （ファイル名またはその一部にマッチするパターン）
                        __Project__/src/lib.test.ts:
                            変更前: test(
                            変更後: test.only(
        mac に Node.js をインストールします（★書きかけ）:
            - https://nodejs.org/ja/download/ >> macOS Installer (.pkg) >> 64-bit
            - ダウンロードしたファイル（例：node-v14.15.0.pkg）を開きます
            - インストール オプションはデフォルトを使用
            - __Application__ が使う Node.js パッケージをインストールします:
                - Launchpad >> Terminal
                - sudo npm install -g  __Package__
            - 実行するときは、NODE_PATH を設定します:
                export NODE_PATH=/usr/local/lib/node_modules
                node  ____.js
        CentOS に Node.js をインストールします（IDEなし）:  #keyword: install Node.js CentOS
            設定: #settings:
                __Node_js_URL__: https://nodejs.org/dist/v14.18.0/node-v14.18.0-linux-x64.tar.xz
                __Node_js_FileName__: node-v14.18.0-linux-x64
            Node.js をインストールします:
                - https://nodejs.org/ja/download/ >> Linux Binaries (x64)（の右の 64-bit を右クリック）>>
                    リンクのコピー
                - コピーした URL をメモします:
                    __Node_js_URL__: https://nodejs.org/dist/v14.18.0/node-v14.18.0-linux-x64.tar.xz  #template: __Node_js_URL__
                    __Node_js_FileName__: node-v14.18.0-linux-x64  #template: __Node_js_FileName__
                - cd ${HOME}
                - curl -L -O https://nodejs.org/dist/v14.18.0/node-v14.18.0-linux-x64.tar.xz  #template: __Node_js_URL__
                - tar -Jxvf  node-v14.18.0-linux-x64.tar.xz  #template: __Node_js_FileName__.tar.xz
                - rm  node-v14.18.0-linux-x64.tar.xz  #template: __Node_js_FileName__.tar.xz
                - sudo mv  node-v14.18.0-linux-x64  /opt  #template: __Node_js_FileName__
                - cd /opt
                - ls  #// 他のバージョンがすでにインストールされているか確認します
                - まだどのバージョンもインストールされていないとき:
                    - sudo ln -s  node-v14.18.0-linux-x64  node  #template: __Node_js_FileName__
                    - cd ${HOME}
                    - PATH=/opt/node/bin:$PATH
                    - node --version
                    - echo 'export PATH="/opt/node/bin:$PATH"' >> ~/.bashrc
                        #// .bashrc は、シェルを再起動するときに実行されます
                - 他のバージョンがすでにインストールされているとき:
                    - sudo rm /opt/node
                    - cd /opt
                    - sudo ln -s  node-v14.18.0-linux-x64  node  #template: __Node_js_FileName__
                    - cd ${HOME}
            yarn をインストールします(CentOS7):
                - su -
                - PATH=/opt/node/bin:$PATH
                - npm install -g yarn
                - exit
        任意のOSに Node.js のプロジェクトをインストールします:  #keyword: run-script-os, OS independent npm-scripts Node.js
            run-script-os:  #// OS に依存しない npm-scripts を作るための補助をします
                https://qiita.com/yfujita0929-tis/items/24407b8006bf2d1c140a
            npm-run-all:  #// 並列動作？
                https://qiita.com/yfujita0929-tis/items/24407b8006bf2d1c140a
        古い npm パッケージをインストールします:
            公開されているパージョンを一覧します:
                npm view __PackageName__ versions
            指定したバージョンをインストールします:
                npm install __PackageName__@__Version__
                #// サンプル: npm install jest@26.6.3
        脆弱性の警告:
            エラーメッセージ: found __Number__ high severity vulnerabilities
            脆弱性があるモジュールの詳細:
                npm audit
    node_modules 以外をコピーします:
        手動:
            フォルダー（エクスプローラー）で node_modules 以外を選択してコピーする
        自動:
            #// _destination フォルダーが新しくできます（元の _destination は削除されます）
            #Git bash
            cd  "__SourceFolder__"
            rm -f   "../_bk-__AnyName__.tar.gz"
            rm -rf  "../_destination"
            tar cvzf  "../_bk-__AnyName__.tar.gz"  --exclude "node_modules"  "."
            mkdir  "../_destination"
            tar xvf   "../_bk-__AnyName__.tar.gz"  --directory  "../_destination"
            rm  "../_bk-__AnyName__.tar.gz"
    コマンド:  #glossary:
        npm init:  #// package.json ファイルを新規作成します
            デフォルトの設定で作ります:
                mkdir -p  __Project__
                cd  __Project__
                npm init -y
            対話しながら作ります:
                mkdir -p  __Project__
                cd  __Project__
                npm init
        npm install:  #// パッケージを追加します
            パッケージをプロジェクトに追加します:
                リリース用:
                    npm install __PackageName__  @types/__PackageName__
                開発用: #// 開発用はリリースするときに含まれません
                    npm install --save-dev __PackageName__  @types/__PackageName__
        npm uninstall:  #// パッケージを除外します
            npm uninstall __PackageName__  @types/__PackageName__
        npm ci:
            node_modules フォルダーを復活します:
                npm ci
        npm list:  #// パッケージとバージョンを一覧します
            サンプル:
                $ npm list
                try_sharp@1.0.0 C:\Users\____\Desktop\try_sharp
                └── sharp@0.30.1
        npm config:
            npm config:  #// エラーメッセージと主なコマンドを表示します
            npm config get:
                全部の設定を表示します: npm config get
                １つの設定を表示します: npm config get __Name__
            npm config set:
                ローカルの場合: npm config set __Name__ __Value__
                グローバルの場合: npm -g config set __Name__ __Value__
            npm config delete:
                ローカルの場合: npm config delete __Name__
                グローバルの場合: npm -g config delete __Name__
            設定値の置き場所:
                表示コマンド: npm config get
                ローカル設定: __Project__/.npmrc
                グローバル設定: /etc/npmrc, %APPDATA%\npm\etc\npmrc  #// -g オプションを付けたときの対象
                ユーザー別設定: ~/.npmrc
                ビルトイン設定: C:\Program Files\nodejs\node_modules\npm\.npmrc
                参考: #ref: https://stackoverflow.com/questions/15536872/nodejs-npm-global-config-missing-on-windows/22847156
npx:  #keyword:  #// コマンドをダウンロードして実行します  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#npx
    設定: #settings:
        __Proxy__: http://host:port
    プロキシ:  #keyword: npx proxy
        CentOS7 にイストールする場合:  #search: CentOS7 proxy React VSCode
        Windows にイストールする場合:  #// 未確認
            コマンド: |  #// 下記は失敗。CentOS7 を使ってください
                #Git bash
                npm -g config set proxy http://host:port             #template: __Proxy__
                npm -g config set https-proxy http://host:port       #template: __Proxy__
                npm -g config set registry http://registry.npmjs.org/
                npm -g config set strict-ssl=false
                npm install --global yarn
                yarn config set proxy http://host:port -g            #template: __Proxy__
                yarn config set https-proxy http://host:port -g      #template: __Proxy__
                npm -g install create-react-app
                yarn global add react react-dom react-scripts react-scripts-ts
nvm:  #keyword:
    nvm のインストール(GitHubから):
        注意:
            Git bashでは使えません
            https://github.com/nvm-sh/nvm/issues/1643
        参考:
            - https://github.com/nvm-sh/nvm#git-install
        以下は未確認:
        nvm をダウンロード（git clone）します:
            #Git Bash
            - cd $HOME
            - git clone https://github.com/nvm-sh/nvm.git .nvm
            - cd .nvm
            - git checkout v0.37.0
        nvm をインストールします:
            - . nvm.sh  #// Activate nvm
        環境変数を設定します:
            ~/.bashrc: |
                export NVM_DIR="$HOME/.nvm"
                [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
                [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
    nvm のアンインストール:
        nvm のフォルダーを削除します:
            #Git Bash
            - cd $HOME
            - rm -rf .nvm
        環境変数を設定します:
yarn:  #keyword:
    yarn をインストールします:
        Node.js をインストールします: #search: install Node.js
        yarn をインストールします:
            npm install --global yarn
            yarn --version
        Node パッケージをインストールします:  #// プロジェクトに追加・削除などします
            インストール:  #keyword: yarn add
                出荷物に含める場合: yarn add  __PachageName__
                開発時だけ含める場合: yarn add --dev  __PachageName__
            アンインストール:  #keyword: yarn remove
                yarn remove  __PachageName__
    node_modules を復帰します:  #keyword: yarn node_modules,  yarn install
        #// 以下のいずれか
        - yarn install --frozen-lockfile  #// yarn.lock に書かれたバージョンを使う場合
        - yarn install  #// 更新も行う場合
    Node パッケージを最新に更新します:
        基本: yarn upgrade-interactive --latest  #// package.json, yarn.lock も更新されます
            #ref: https://classic.yarnpkg.com/en/docs/cli/upgrade-interactive
            #// または yarn upgrade --latest  #// 未確認  #// package.json, yarn.lock も更新されます
        package.json は更新しない場合: yarn upgrade  #// 未確認
        指定したパッケージだけ更新します: yarn upgrade __PackageName__  #// 非推奨  #search: version upgrade debug
        指定したパッケージだけ指定したバージョンに変更します: yarn upgrade __PackageName__@__Version__  #// 非推奨  #search: version upgrade debug
        参考:
            構成のバージョンアップ:  #search: version upgrade debug
    プロキシ:
        参照:
            yarn config get proxy
            yarn config get https-proxy
            yarn config list
        設定:
            全シェル:
                yarn config set proxy http://example.com:port -g
                yarn config set https-proxy http://example.com:port -g
                yarn config set proxy http://username:password@host:port -g
                yarn config delete __Name___
            PowerShell:
                $env:NO_PROXY = "192.168.56.102"
        参考: #ref: https://one-sthead.hatenablog.com/entry/2019/07/02/122304
    yarn コマンド:
        yarn install: #ref: https://classic.yarnpkg.com/en/docs/cli/install
bower:  #keyword:
    公式: #ref: https://github.com/bower/bower
    インストール:
        Git bash など:
            npm install -g bower
    サンプル: #focus: bower
        mkdir -p __Project__
        cd  __Project__
        bower install json-human --save
DOM: #keyword:
    HTML の DOM:
        getElementById: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#getElementById_document
            const  result = document.getElementById('result');
        innerHTML:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#innerHTML
            document.getElementById("result").innerHTML = "<A href=\"http://www.example.com/\">web</A>";
    XML の DOM: #ref: ${programming}/HTML ブラウザ/XML.svg#dom_ref
jQuery:  #keyword:
    記号:
        (#): セレクターに指定する id 属性
        (.): セレクターに指定する class 属性
        (@): 古い仕様。属性の前に @ を書いていましたが、jQuery 1.3 以降は不要です  #ref: http://semooh.jp/jquery/cont/doc/release_1.3/
        ([]): セレクターに指定する その他の属性
    本家: #ref: https://jquery.com/
        API: #ref: https://api.jqueryui.com/
        Learning Center: #ref: https://learn.jquery.com/
            jQuery のしくみ: #ref: https://learn.jquery.com/about-jquery/how-jquery-works/
    セレクター:  #keyword: jQuery selector
        基本: |  #focus: $, aTag
            var  aTag = $('a')  #// $ がセレクターです。セレクターの返り値は HTML 要素などを操作するためのオブジェクトです
            aTag[0].text()
        id 属性: $(#__ID__'), $('#test1')  #// <a id="test1">____</a>
        class 属性: $(.__ClassName__'), $('.class1')  #// 非推奨  #// <a class="class1">____</a>
        その他の属性: $('__TagName__[__AttributeName__="__Value__"]'), $('a[name="name1"]')  #// <a name="name1">____</a>
        タグ名: $('a')  #// <a>____</a>
        親要素から指定: $('div > span')  #// <div><span>____</span></div> の <span>
        OR: $('#text1,#text2')  #// コンマ
        NOT: $('@:not(#text2)')  #// @:not(____)
        参考:
            #ref: https://api.jquery.com/category/selectors/
            #ref: https://learn.jquery.com/using-jquery-core/selecting-elements/
            #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#JQuery_selector
Next.js: #keyword:
    公式:
        Getting Started: #ref: https://nextjs.org/docs/getting-started
        GitHub issue: #ref: https://github.com/vercel/next.js/issues
        Document: #ref: https://nextjs.org/docs
        Learn: #ref: https://nextjs.org/learn
        Examples:
            #ref: https://github.com/vercel/next.js/tree/master/examples
            #search: vercel/next-learn
    概要:
        高速:
            SSG(getStaticProps, 推奨), SSR(getServerSideProps), SPA(next export):
            client side navigation, プリフェッチ: #ref: https://nextjs.org/learn/basics/navigate-between-pages/client-side
            プリレンダリング: #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering
                パフォーマンスとSEOを向上させることができます。プレーン React.js にはない
            hydration: #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering
                初期ロードで静的 HTML をプリレンダリングして表示してから hydration でインタラクティブになります。
        ファイル ベース ルーティング:
        参考: #ref: https://qiita.com/Yuki_Oshima/items/5c0dfd8f7af8fb76af8f
    手順 >> チュートリアル: #keyword: install Next.js
        公式:
            プロジェクト生成: #ref: https://nextjs.org/learn/basics/create-nextjs-app
            ナビゲーション:
                create-next-app: #// プロジェクト生成  #ref: https://nextjs.org/learn/basics/navigate-between-pages/setup
                pages フォルダー: #// URL とページの対応関係  #ref: https://nextjs.org/learn/basics/navigate-between-pages/pages-in-nextjs
                <Link>: #// ハイパーリンク  #ref: https://nextjs.org/learn/basics/navigate-between-pages/link-component
                高速化: #// Client-Side Navigation  #ref: https://nextjs.org/learn/basics/navigate-between-pages/client-side
            画像、メタデータ、外部スクリプト、CSS: #ref: https://nextjs.org/learn/basics/assets-metadata-css
                <Image>: #ref: https://nextjs.org/learn/basics/assets-metadata-css/assets
                    Web Vitals: #search:  #// Web のパフォーマンス指標の1つ。読み込み速度など
                <Head>: #ref: https://nextjs.org/learn/basics/assets-metadata-css/metadata
                <Script>: #ref: https://nextjs.org/learn/basics/assets-metadata-css/third-party-javascript
                CSS: #ref: https://nextjs.org/learn/basics/assets-metadata-css/css-styling
                レイアウト コンポーネント: #ref: https://nextjs.org/learn/basics/assets-metadata-css/layout-component
                グローバル CSS: #ref: https://nextjs.org/learn/basics/assets-metadata-css/global-styles
                Polishing Layout: #ref: https://nextjs.org/learn/basics/assets-metadata-css/polishing-layout
                スタイリングのヒント: #ref: https://nextjs.org/learn/basics/assets-metadata-css/styling-tips
            プリレンダリング: #ref: https://nextjs.org/learn/basics/data-fetching
                Pre-rendering: #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering
                2種類のプリレンダリング: #ref: https://nextjs.org/learn/basics/data-fetching/two-forms
                    #// ページごとに選択できます
                    静的生成: ビルド時に生成
                    サーバーサイドレンダリング: oneachリクエスト。開発時（npm run dev）はこちら
                getStaticProps:  #ref: https://nextjs.org/learn/basics/data-fetching/with-data
                ビルド時に実行する getStaticProps:  #ref: https://nextjs.org/learn/basics/data-fetching/getstaticprops-details
                リクエスト時に実行する getServerSideProps:  #ref: https://nextjs.org/learn/basics/data-fetching/request-time
                SWR:  #ref: https://nextjs.org/learn/basics/data-fetching/request-time
        TypeScript のプロジェクト: #keyword: new Next.js TypeScript
            新規作成済みプロジェクト: #keyword: next_js_minimum
                #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_minimum
                編集箇所:
                    main タグの中
                    #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_minimum/pages/index.tsx#<main
                編集したプロジェクトのサンプル:
                    #search: next_js_sass
            新規作成:
                cd __ParentOfProject__
                npx create-next-app@latest --ts __ProjectName__
                cd __ProjectName__
                npm run dev
                http://localhost:3000
                #ref: https://nextjs.org/docs/api-reference/create-next-app
            サンプル:
                プロジェクト:
                    typescript-final: #keyword:
                        local: #ref: ${GitClone}/GitHub/vercel/next-learn/basics/typescript-final
                        internet: #ref: https://github.com/vercel/next-learn/tree/master/basics/typescript-final
                    vercel/next-learn: #keyword:
                        #ref: ${GitClone}/GitHub/vercel/next-learn
                        #ref: https://github.com/vercel/next-learn
                プロジェクトから起動します:
                    npm install
                    npm run dev
                    http://localhost:3000
            #ref: https://nextjs.org/learn/excel/typescript
        Next.js アプリを新規作成します: #ref: https://nextjs.org/learn/basics/create-nextjs-app/setup
            - cd ~/Desktop
            - npx create-next-app nextjs-blog --use-npm --example "https://github.com/vercel/next-learn/tree/master/basics/learn-starter"
            - cd nextjs-blog  #// __Project__
            - npm run dev
            - http://localhost:3000  #// Welcome to Next.js! と表示されます
                #// npm run dev を実行したターミナルで Ctrl+C を押します
        ページを編集します: #keyword: Next.js pages  #// __Project__/pages
            HTML が書かれたファイルを開きます:
                - code  __Project__  #// Visual Studio Code を開きます
                - code  __Project__/pages/index.js
            編集します:
                変更前: Welcome to
                変更後: Learn
            ブラウザーに表示されていたページが自動的に更新されます:
                Fast Refresh: #ref: https://nextjs.org/docs/basic-features/fast-refresh
        <Link>, ハイパーリンクを作ります: #keyword: Next.js <Link>  #ref: https://nextjs.org/learn/basics/navigate-between-pages/link-component
            書式: <Link href="____"><a>____</a></Link>
            pages/index.js :
                編集前:  |
                    <h1 className="title">
                        Learn <a href="https://nextjs.org">Next.js!</a>
                    </h1>
                編集後: |  #focus: Link
                    import Link from 'next/link'
                        :
                    <h1 className="title">
                        Read{' '}
                        <Link href="/posts/first-post">
                            <a>this page!</a>
                        </Link>
                    </h1>
        <Image>, 画像: #keyword: Next.js <Image>, Next.js public  #ref: https://nextjs.org/docs/api-reference/next/image
            自動画像最適化:
                WebPなどの最新の形式で画像のサイズ変更、最適化、および提供が可能になります
                デフォルトで遅延ロードされています。
                #ref: https://nextjs.org/docs/basic-features/image-optimization
            サンプル: |
                import Image from 'next/image'
                    :
                <Image
                    src="/images/profile.jpg"  // __Project__/public/images/profile.jpg
                    height={144} width={144} alt="Your Name"
                />
        <Head>, ページのメタ属性. タイトルなど: #keyword: Next.js <Head> <title>  #ref: https://nextjs.org/learn/basics/assets-metadata-css/metadata
            __Public__/pages/posts/first-post.js : |  #focus: Head
                import Head from 'next/head'

                export default function FirstPost() {
                    return <>
                        <Head>
                            <title>First Post</title>
                        </Head>
                        <h1>First Post</h1>
                    </>
                }
            #ref: https://nextjs.org/docs/api-reference/next/head
        <Script>: #keyword: Next.js <Script>  #ref: https://nextjs.org/learn/basics/assets-metadata-css/third-party-javascript
            __Public__/pages/posts/first-post.js : |  #focus: Script
                import Script from 'next/script'
                    :
                <Head>
                    <title>First Post</title>
                </Head>
                <Script
                    src="https://connect.facebook.net/en_US/sdk.js"
                    strategy="lazyOnload"
                    onLoad={() =>
                        console.log(`script loaded correctly, window.FB has been populated`)
                    }
                />
        CSS: #keyword: Next.js CSS tutorial
            <style jsx>: #keyword: Next.js style jsx  #ref: https://nextjs.org/learn/basics/assets-metadata-css/css-styling
                __Project__/pages/index.js : |  #focus: style
                    <Head>
                        :
                    </Head>

                    <style jsx>{`
                        .container {
                            min-height: 100vh;
                            padding: 0 0.5rem;
                        }
                    `}</style>
                CSS: #ref: https://nextjs.org/docs/basic-features/built-in-css-support
                styled-jsx: #keyword: styled-jsx, CSS-in-JS  #ref: https://github.com/vercel/styled-jsx
                    概要: CSS-in-JS の1種。Next.js は styled-components や emotion も選べます。
                        CSSスタイルはスコープ付けされます。
                    関連:
                        styled-components: #ref: https://github.com/vercel/next.js/tree/canary/examples/with-styled-components
                        emotion: #ref: https://github.com/vercel/next.js/tree/canary/examples/with-emotion
                .css, .scssファイル: #// インポートできます
                    関連:
                        Tailwind CSS: #ref: https://github.com/vercel/next.js/tree/canary/examples/with-tailwindcss
            import styles from, ローカル CSS ファイルのインポート: #keyword: Next.js import styles from  #ref: https://nextjs.org/learn/basics/assets-metadata-css/layout-component
                #// 下記は div 要素に相当する Layout コンポーネントに CSS を設定しています
                __Project__/components/layout.js : |  #focus: container, styles, Layout
                    import styles from './layout.module.css'

                    export default function  Layout({ children }) {
                        return <div className={styles.container}>{children}</div>
                    }
                __Project__/components/layout.module.css : |  #// ファイル名の末尾は .module.css であること
                    .container {
                        max-width: 36rem;
                        padding: 0 1rem;
                        margin: 30rem auto 6rem;
                    }
                __Project__/pages/posts/first-post.js : |  #focus: Layout
                    import Layout from '../../components/layout'

                    export default function FirstPost() {
                        return (
                            <Layout>
                                <Head>
                                    :
                            </Layout>
                        )
                    }
                作られるスコープ付きの CSS のクラス名:
                    <div class="layout_container__fbLkO">  #// layout は CSS ファイル名の一部, fbLkO は CSS ファイルごとに一意のハッシュ
            App コンポーネント, グローバル CSS:  #keyword: Next.js App global.css  #ref: https://nextjs.org/learn/basics/assets-metadata-css/global-styles
                __Project__/pages/_app.js : |  #// パスは固定
                    import '../styles/global.css'

                    export default function App({ Component, pageProps }) {  // App is common component in all pages.
                        return <Component {...pageProps} />
                    }
                __Project__/styles/global.css : |
                    html,
                    body {
                        padding: 0;
                        margin: 0;
                        font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu,
                            Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
                        line-height: 1.6;
                        font-size: 18px;
                        color: green;
                    }

                    * {
                        box-sizing: border-box;
                    }

                    a {
                        color: #0070f3;
                        text-decoration: none;
                    }

                    a:hover {
                        text-decoration: underline;
                    }

                    img {
                        max-width: 100%;
                        display: block;
                    }
                上記 App を追加したとき:
                    エラーになります:
                        ブラウザー内:
                            About to perform a full refresh
                    サーバーの再起動でエラーは解消されます:
                        Ctrl + C >> npm run dev
            .scss, .sass:  #ref: https://nextjs.org/learn/basics/assets-metadata-css/styling-tips
                コマンド: npm install sass --save-dev
                プロジェクト: #keyword: next_js_sass
                    #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_sass
            classnames:  #keyword: JedWatson classnames  #// プロパティの値に応じて CSS のクラスを切り替えます
                __Project__/pages/____.jsx : |  #focus: success, cn
                    import styles from './alert.module.css'
                    import cn from 'classnames'

                    <div
                        className={cn({
                            [styles.success]: type === 'success',
                            [styles.error]: type === 'error'
                        })}
                    >
                __Project__/pages/alert.module.css : |
                    .success {
                        color: green;
                    }
                    .error {
                        color: red;
                    }
                #ref: https://nextjs.org/learn/basics/assets-metadata-css/styling-tips
            PostCSSの設定:  #ref: https://nextjs.org/learn/basics/assets-metadata-css/styling-tips
                __Project__/postcss.config.js: |
                    module.exports = {
                        plugins: {
                            tailwindcss: {},
                            autoprefixer: {}
                        }
                    }
        bootstrap: #keyword: Next.js bootstrap
            react-bootstrap:
                #search: Next.js react-bootstrap
                #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_bootstrap
                #ref: https://react-bootstrap.github.io/getting-started/introduction
            with-react-bootstrap:
                #ref: ${GitClone}/GitHub/vercel/next.js/examples/with-react-bootstrap
                #ref: https://github.com/vercel/next.js/tree/canary/examples/with-react-bootstrap
        Pre-rendering: #keyword: Next.js pre-rendering tutorial  #ref: https://nextjs.org/learn/basics/data-fetching/pre-rendering
            getStaticProps: #keyword: Next.js getStaticProps  #ref: https://nextjs.org/learn/basics/data-fetching/with-data
                概要:
                    データの流れ: getStaticProps の返り値が Home コンポーネントの引数に渡ります。
                    実行環境: サーバー。ビルド時？  #// Node.js でできる DB クエリーなどができます  #ref: https://nextjs.org/learn/basics/data-fetching/getstaticprops-details
                    定義場所: __Project__/pages 内
                プロジェクト: #ref: ${GitHub}/Trials/try_Next_js_pre_rendering
                    npm ci
                    npm run dev
                    http://localhost:3000
                手順:
                    gray-matter をインストールします:
                        npm install gray-matter
                    __Project__/pages/index.js: |  #focus: getStaticProps, allPostsData, getSortedPostsData
                        import { getSortedPostsData } from '../lib/posts'

                        // This return value will be passed to Home component
                        export async function  getStaticProps() {
                            return {
                                props: {
                                    allPostsData: getSortedPostsData()
                                }
                            }
                        }

                        export default function  Home({ allPostsData }) {
                            return (
                                <Layout home>
                                    <Head>

                                        :

                                    </Head>
                                    <section className={utilStyles.headingMd}>

                                        :

                                    </section>
                                    <section className={`${utilStyles.headingMd} ${utilStyles.padding1px}`}>
                                        <h2 className={utilStyles.headingLg}>Blog</h2>
                                        <ul className={utilStyles.list}>
                                            {allPostsData.map(({ id, date, title }) => (
                                                <li className={utilStyles.listItem} key={id}>
                                                    {title}
                                                    <br />
                                                    {id}
                                                    <br />
                                                    {date}
                                                </li>
                                            ))}
                                        </ul>
                                    </section>
                                </Layout>
                            )
                        }
                    __Project__/lib/posts.js : |  #focus: getSortedPostsData, allPostsData, matter
                        import fs from 'fs'
                        import path from 'path'
                        import matter from 'gray-matter'

                        const postsDirectory = path.join(process.cwd(), 'posts')

                        export function  getSortedPostsData() {
                            const  fileNames = fs.readdirSync(postsDirectory)

                            const  allPostsData = fileNames.map(fileName => {
                                const id = fileName.replace(/\.md$/, '')
                                const fullPath = path.join(postsDirectory, fileName)
                                const fileContents = fs.readFileSync(fullPath, 'utf8')

                                // Use gray-matter to parse the post metadata section
                                const matterResult = matter(fileContents)

                                // Combine the data with the id
                                return {
                                    id,
                                    ...matterResult.data
                                }
                            })

                            return  allPostsData.sort(({ date: a }, { date: b }) => {
                                if (a < b) {
                                    return 1
                                } else if (a > b) {
                                    return -1
                                } else {
                                    return 0
                                }
                            })
                        }
                    __Project__/posts/pre-rendering.md : |
                        ---
                        title: 'Two Forms of Pre-rendering'
                        date: '2020-01-01'
                        ---

                        Next.js has two forms of pre-rendering: **Static Generation** and **Server-side Rendering**. The difference is in **when** it generates the HTML for a page.

                        - **Static Generation** is the pre-rendering method that generates the HTML at **build time**. The pre-rendered HTML is then _reused_ on each request.
                        - **Server-side Rendering** is the pre-rendering method that generates the HTML on **each request**.

                        Importantly, Next.js lets you **choose** which pre-rendering form to use for each page. You can create a "hybrid" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.
                    __Project__/posts/ssg-ssr.md : |
                        ---
                        title: 'When to Use Static Generation v.s. Server-side Rendering'
                        date: '2020-01-02'
                        ---

                        We recommend using **Static Generation** (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.

                        You can use Static Generation for many types of pages, including:

                        - Marketing pages
                        - Blog posts
                        - E-commerce product listings
                        - Help and documentation

                        You should ask yourself: "Can I pre-render this page **ahead** of a user's request?" If the answer is yes, then you should choose Static Generation.

                        On the other hand, Static Generation is **not** a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.

                        In that case, you can use **Server-Side Rendering**. It will be slower, but the pre-rendered page will always be up-to-date. Or you can skip pre-rendering and use client-side JavaScript to populate data.
        URL: #keyword: Next.js URL tutorial
            参考 >> 基本: #search: Next.js file system routing
            dynamic URL static page: #keyword: Next.js dynamic URL static page  #ref: https://nextjs.org/learn/basics/dynamic-routes/page-path-external-data
                概要:
                    URL の中にある ID の部分を展開したページをビルド時に作ります
                基本:
                    ファイルの置き場所: __Project__/pages/__Type__/[id].js  #// [id] はそのままファイル名にします。[id] の部分はビルド時に展開されます
                    getStaticPaths: id のリストを返すコールバック関数。
                    getStaticProps: id に対応したコンテンツを返すコールバック関数。定義したファイルの default function に渡されます。
                    サンプル:
                        pages/posts/[id].js : |  #focus: getStaticPaths, params, getStaticProps, postData
                            import Layout from '../../components/layout'
                            import { getAllPostIds, getPostData } from '../../lib/posts'

                            export async function  getStaticPaths() {
                                return {
                                    paths: getAllPostIds(),
                                        // [ { params: { id: 'pre-rendering' } }, { params: { id: 'ssg-ssr' } } ]
                                    fallback: false
                                }
                            }

                            export async function  getStaticProps({ params }) {
                                    // 1st call: { id: 'ssg-ssr' }
                                    // 2nd call: { id: 'pre-rendering' }
                                return {
                                    props: {
                                        postData: getPostData(params.id)
                                    }
                                }
                            }

                            export default function  Post({ postData }) {
                                return (
                                    <Layout>
                                        {postData.title}
                                        <br />
                                        {postData.id}
                                        <br />
                                        {postData.date}
                                    </Layout>
                                )
                            }
                        lib/posts.js : |
                            export function  getAllPostIds() {
                                const fileNames = fs.readdirSync(postsDirectory)

                                return fileNames.map(fileName => {
                                    return {
                                        params: {
                                            id: fileName.replace(/\.md$/, '')
                                                // e.g. 'ssg-ssr', 'pre-rendering'
                                        }
                                    }
                                })
                            }

                            export function  getPostData(id) {
                                const fullPath = path.join(postsDirectory, `${id}.md`)
                                const fileContents = fs.readFileSync(fullPath, 'utf8')

                                const matterResult = matter(fileContents)

                                return {
                                    id,
                                    ...matterResult.data
                                }
                            }
                        開く:
                            #ref: http://localhost:3000/posts/ssg-ssr
                            #ref: http://localhost:3000/posts/pre-rendering
                キャッチ オール ルート: #// [...id]
                    ファイルの置き場所: __Project__/pages/__Type__/[...id].js
                    概要: "[...id] の部分は / も含みます。a だけでなく、a/b、a/b/cなどにも一致します。"
                    getStaticPaths 関数のサンプル: |
                        export async function  getStaticPaths() {
                            return {
                                paths: getAllPostIds(),
                                    // [
                                    //    { params: { id: ['a', 'b', 'c'] } },  // /__Type__/a/b/c
                                    //    { params: { id: ['a', 'b', 'x'] } },  // /__Type__/a/b/x
                                    // ]
                                fallback: false
                            }
                        }
            Dynamic Routes: #keyword: Next.js dynamic routes  #ref: https://nextjs.org/docs/routing/dynamic-routes
                概要: http://__Domain__/__Name__?foo=bar の __Name__, foo, bar を辞書変数で受け取ります
                pages/__Name__.js :  #focus: useRouter, router  #keyword: Next.js useRouter query
                    URL => query object: |
                        http://__Domain__/__Name__?foo=bar => { "foo": "bar" }
                    コード: |
                        import { useRouter } from 'next/router'

                        const Post = () => {
                            const router = useRouter();

                            return <p>__Name__.tsx: {Object.entries(router.query).toString()}</p>
                        }

                        export default Post
                pages/[__Name__].js :  #// __Name__ と一致しない場合
                    URL => query object: |
                        http://__Domain__/abc => { "__Name__": "abc" }
                        http://__Domain__/abc?foo=bar => { "__Name__": "abc", "foo": "bar" }
                    コード: |
                        import { useRouter } from 'next/router'

                        const Post = () => {
                            const router = useRouter();

                            return <p>[__Name__].tsx: {Object.entries(router.query).toString()}</p>
                        }

                        export default Post
            API routes: #keyword: Next.js API routes  #ref: https://nextjs.org/learn/basics/api-routes
                pages/api/hello.js : |
                    // http://localhost:3000/api/hello
                    export default function  handler(req, res) {
                        res.status(200).json({ text: 'Hello' });
                    }
                pages/api/post/[id].js : |
                    export default function  handler(req, res) {
                        const { id } = req.query;  // id はファイル名に含まれる [ ] の中と同じ名前にします
                        res.end(`Post: ${id}`);
                    }
            404ページ:  #// Not found page  #ref: https://nextjs.org/learn/basics/dynamic-routes/dynamic-routes-details
                __Project__/pages/404.js : |
                    export default function Custom404() {
                        return <h1>404 - Page Not Found</h1>
                    }
            ルーター: #// Next.js ルーター
                useRouter フック  #ref: https://nextjs.org/learn/basics/dynamic-routes/dynamic-routes-details
        remark: #search: remark  #// Markdown を HTML に変換します
        date-fns: #search:  #// 日付の表示形式
        その他の サンプル ページ: #ref: https://nextjs.org/learn/basics/dynamic-routes/dynamic-routes-details >> More Examples
        デバッガーと接続します:  #keyword: Next.js debugger
            参考: #ref: https://nextjs.org/docs/advanced-features/debugging
            __Project__/.vscode/launch.json ファイルを以下の内容で作ります: |
                {
                    "version": "0.2.0",
                    "configurations": [
                        {
                            "name": "Next.js: debug server-side",
                            "type": "node-terminal",
                            "request": "launch",
                            "command": "npm run dev"
                        },
                        {
                            "name": "Next.js: debug client-side",
                            "type": "pwa-chrome",
                            "request": "launch",
                            "url": "http://localhost:3000"
                        },
                        {
                            "name": "Next.js: debug full stack",
                            "type": "node-terminal",
                            "request": "launch",
                            "command": "npm run dev",
                            "console": "integratedTerminal",
                            "serverReadyAction": {
                                "pattern": "started server on .+, url: (https?://.+)",
                                "uriFormat": "%s",
                                "action": "debugWithChrome"
                            }
                        }
                    ]
                }
            Run and Debug ビュー（左）を表示します:
                Windows: Shift + Ctrl + D キー
                mac: Shift + Command + D キー
            デバッガーを接続する位置を選びます:
                debug full stack: 通常、これを選びます。 pages/*.tsx (client), pages/api/*.tsx (server)
                debug server-side:
                debug client-side:
            デバッグを開始します:
                F5 キーを押します。
                npm run dev が実行中だったら終了してから開始します
        Vercel にデプロイ: #ref: https://nextjs.org/learn/basics/deploying-nextjs-app
            #// GitHub アカウントがあり、GitHub にログインしてから  #search: GitHub new repository
            Vercel を開きます:
                https://vercel.com/signup
            （初回のみ）サイン アップ します:
                Continue with GitHub ボタン（右上）:
                Authorize Vercel ボタン（下）:
                #// https://vercel.com/import/git が開きます
            プロジェクトを Vercel にインポートしてデプロイします:
                （初回の場合）:
                    Import Git Repository（の下）>> Add GitHub Account >>（アカウント名）
                    （続く）
                （2回目以降で久しぶりの場合）:
                    Configure GitHub App
                    （続く）
                共通:
                    Only select repositories >>（リポジトリ名）>> Install または Save（下）>>
                    Import（対象リポジトリの右）>> Deploy ボタン（右下）
            デプロイしたページを開きます:
                https://vercel.com/takakiriy/nextjs-blog
                Overview タブ >> Visit（右上）
            プロジェクトを Vercel から削除します:
                URL の例: https://vercel.com/takakiriy/nextjs-blog
                メニュー: Settings タブ >> Advanced（左下）>> Delete Project（右下）
    ルーティング: #// URL とページの対応関係
        ルーティング:  #search: Next.js URL tutorial
        ファイル システム ルーティング: #keyword: Next.js file system routing, Next.js file base routing, 統合ファイルシステムルーティング
            概要: #// URL はコードのパスにあわせて決まります
                たとえば、URL
                    __Domain__/api
                は、
                    __Project__/pages/api/index.js
                または
                    __Project__/pages/api.tsx
                にソースがあります。
                pages の右がドメインの右に対応します。
            公式: #ref: https://nextjs.org/docs/routing/introduction
            URL パラメーター: |  #// URL の一部を変数で受け取ります
                たとえば、
                    __Project__/pages/api/[id].tsx
                というファイルがあるときに、URL
                    __Domain__/api/1
                にアクセスすると、
                    [id].tsx:
                に
                    {"id": "1"}
                が渡ります
            特殊なファイル名:
                404.tsx: ファイルが存在しない URL にアクセスしたときに表示される内容
                _app.tsx: アプリケーションエントリーポイント, Context Provider などを書きます
                _document.tsx: HTMLドキュメント構造記述用, HTML のヘッダーを書きます
        型安全ルーティング: #keyword:
            概要: |
                たとえば、
                    <Route path="/user/:userId">
                の
                    "/user/:userId"
                から
                    const params = useParams<{ userId: string }>();
                の
                    { userId: string }
                を自動的に定義します。
                userId の部分は必ず string 型ですが、
                params.userId が存在することは "/user/:userId" を解析しなければ分かりません。
            参考: #ref: https://zenn.dev/uhyo/articles/type-safe-routing-2021#文字列ベースのルーティングの危険性
    API 呼び出し: #keyword: Next.js API
        read する API:
            Pre-rendering:
                概要: getStaticProps 関数を定義します  #search: getStaticProps
                サンプル: |  #ref: ${GitClone}/GitHub/vercel/next-learn/basics/typescript-final/pages/posts/[id].tsx
                    import { GetStaticProps, GetStaticPaths } from 'next'
                    export const getStaticProps: GetStaticProps = async ({ params }) => {
            Dynamic Routes: #keyword: Next.js Dynamic Routes API
                #search: Next.js dynamic routes 
                呼び出すとき: | #ref: ${GitHub}/typrm-html/pages/search.tsx
                    import { useRouter } from 'next/router';
                    import { useState, useEffect } from 'react';

                    const Post = () => {
                        const [contents, setContents] = useState<string>('');

                        useEffect(() => {
                            const asyncFunction = async () => {

                                const response = await fetch('/api/search');  // __Project__/pages/api/search.ts
                                const aJSON = JSON.stringify(await response.json(), null, '    ');
                                setContents(aJSON);
                            }

                            asyncFunction()
                                .catch(console.error);
                        }, []);

                        return <>
                            <p>{contents}</p>
                        </>;
                    }

                    export default Post
                呼び出される関数:
                    API routes: #search: Next.js API routes
        write する API:
            #search: Next.js Dynamic Routes API
    コンポーネント:
        サンプル:
            親コンポーネント:
                __Project__/pages/posts/[id].tsx: |
                    import Date from '@components/date'
                    <Date dateString={postData.date} />
                #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_bootstrap/pages/posts/[id].tsx#<Date
                #// @components については #search: import @ TypeScript
            子コンポーネント:
                __Project__/components/date.tsx: |
                    export default function Date({ dateString }: { dateString: string }) {
                #ref: ${GitHub}/MyPrivateCode/Next_js/next_js_bootstrap/components/date.tsx#Date
    CSS: #// Next.js では CSS と Sass が使えます
        サンプル プロジェクト: #search: Sass
        公式チュートリアル: #search: Next.js CSS tutorial
    高速化:
        #search: Next.js pre-rendering tutorial
        高速リロードの対応条件:
            条件: 名前付き関数コンポーネント(React)を export default すること
            サンプル:
                const Index = () => <div/>;
                export default Index;
        ビルド時に画像サイズを調整します:
            条件: next/image を使います
            サンプル: | #focus: Image
                import Image from 'next/image'

                function Home() {
                return (
                    <>
                        <h1>My Homepage</h1>
                        <Image
                            src="/me.png"
                            alt="Picture of the author"
                            width={500}
                            height={500}
                        />
                        <p>Welcome to my homepage!</p>
                    </>
                    )
                }

                export default Home
React:
    React:  #keyword:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React
        概要:
            SPA。HTML が JavaScript のリテラルになる（.tsx, .jsx）。
        手順:
            React をインストールします:  #keyword: install React,  install React VSCode  #// Jest + TypeScript + React + Visual Studio Code の開発環境を構築します
                プロキシが無い環境 for Windows: #keyword: install Windows React VSCode
                    参考:
                        Jest - TypeScript Deep Dive 日本語版:
                            https://typescript-jp.gitbook.io/deep-dive/intro-1/jest
                        React × TypeScript環境にJestを導入してみて:
                            https://tech.willgate.co.jp/entry/2019/12/12/130000
                    設定: #settings:
                        __RepositoryName__: react1_jest
                        __GitCollaboratorName__: Your Name  #search: Git username
                        __GitCollaboratorMail__: you@example.com
                    注意: React のプロジェクト名に使える文字に制限があるので、
                        先に React のプロジェクトを作ってから、GitHub のプロジェクトを作ります。
                        npm に登録されているパッケージ名は、小文字とハイフンだけ使われているようです。
                    準備:
                        Node.js をインストールします（React が使います）:
                            - https://nodejs.org/ja/download/ >> Windows Installer (.msi) >> 64-bit
                            - node-v14.15.0-x64.exe をダブルクリックします
                            - インストール オプションはデフォルトを使用
                        Git for Windows をインストールします（シェルとして使います）:
                            - https://git-scm.com/ >> Downloads >> Windows
                            - ダウンロードしたファイル（例：Git-2.29.2.2-64-bit.exe）を開きます
                            - Next を8回押す
                            - Configuring the line ending conversions: Checkout as-is, commit as-is
                            - 他のインストール オプションはデフォルトを使用
                            - デスクトップを右クリック >> Git Bash Here
                            - git clone  "https://github.com/githubtraining/hellogitworld.git"
                            - 成功したら、デスクトップにある hellogitworld フォルダーを削除します ( rm -rf hellogitworld )
                        （ダウンロード（クローン）するリポジトリにコミットする可能性があるとき）Git のユーザー名を設定します:
                            - git config --global user.email "you@example.com"  #template: "__GitCollaboratorMail__"
                            - git config --global user.name  "Your Name"        #template: "__GitCollaboratorName__"
                            - Git bash を閉じます:
                        Visual Studio Code をインストールします:
                            - https://code.visualstudio.com/
                            - インストール オプションはデフォルトを使用
                            - （推奨）Visual Studio Code をタスクバーにピン止めします:
                            - （推奨）Ctrl + S キーを押したときに全てのファイルを保存するように設定します: |
                                File >> Preferences >> Keyboard Shortcuts >> save all （と入力） >>
                                    File: Save All （をダブルクリック） >> Ctrl + S キー >> Enter キー
                            - 下記の拡張機能をインストールします :
                                - Jest Runner
                    React のプロジェクトを新規作成します:
                        プロジェクトを作ります:
                            #Git bash
                            - cd  "__ParentOfProject__"
                            - （TypeScript を使う場合）:
                                - npx create-react-app --template typescript  "react1_jest"  #template: "__RepositoryName__"
                            - （JavaScript を使う場合）:
                                - npx create-react-app  "react1_jest"  #template: "__RepositoryName__"
                        Visual Studio Code でプロジェクトを開きます:
                            - code  "react1_jest"  #template: "__RepositoryName__"
                        動作確認します:
                            Terminal を開きます:
                                VSCode >> Terminal >> New Terminal
                            コマンドを入力します:
                                #Git bash
                                npm start
                                #// Windows Defender によって警告されたときは、アクセス許可します
                                #// ブラウザーが開いたら閉じます
                            Web サーバーを終了します:
                                Ctrl + C
                                #// ウィンドウをクローズすると node.exe のプロセスが残ってしまいます
                    GitHub にアップロードします:
                        リポジトリを新規作成します:
                            URL: https://github.com >>（サインインしていなかったらサインイン）
                            New ボタン（Repositories:左上）:
                            リポジトリ名: react1_jest  #template: __RepositoryName__
                        git push します: |  #keyword: git first commit push
                            cd  "react1_jest"  #template: __RepositoryName__
                            git remote add origin https://github.com/Your Name/react1_jest.git
                                #template: __GitCollaboratorName__/__RepositoryName__
                            git branch -M main  #// 必要ならブランチ名を main に変更します
                            git config user.name
                            git config user.email
                            git push --set-upstream origin main  #// main に変更していなかったら master
                        参考: #ref: リポジトリを新規作成した後の「…or create a new repository on the command line:」
                    Visual Studio Code でデバッグできるようにします:
                        Visual Studio Code で __Project__ フォルダーを開きます（エディターとして使うため）:
                            メニュー: File >> Open Folder >> react1_jest  #template: __RepositoryName__
                        必要な Node パッケージをインストールします:
                            #VSCode >> Terminal >> New Terminal
                            - npm install  "ts-jest" --save-dev
                        __Project__/package.json に下記の jest キーを追加します: |
                            "jest": {
                                "transform": {
                                    "^.+\\.tsx?$": "ts-jest",
                                    "^.+\\.jsx?$": "babel-jest"
                                }
                            }
                    テスト対象のコードを作成します:
                        （TypeScript を使う場合）:
                            __Project__/src/foo.ts: |
                                export const sum = (...a: number[]) =>
                                    a.reduce(
                                        (acc, val) => acc + val,
                                        0);
                        （JavaScript を使う場合）:
                            __Project__/src/foo.js: |
                                export const sum = (...a) =>
                                    a.reduce(
                                        (acc, val) => acc + val,
                                        0);
                    テスト コードを作成します:
                        __Project__/src/foo.test.ts (または .js) : |
                            import { sum } from './foo';

                            test('basic', () => {
                                expect(sum()).toBe(0);
                            });

                            test('basic again', () => {
                                expect(sum(1, 2)).toBe(3);
                            });
                    デバッグできることを確認します:
                        Visual Studio Code で __Project__ フォルダーを開きます:
                            メニュー: File >> Open Folder >> react1_jest  #template: __RepositoryName__
                        __Project__/src/foo.test.ts (または .js) ファイルを開きます:
                        test 関数の中にブレークポイントを張ります:
                            行番号の左をクリックします:
                        デバッグを開始します:
                            test 関数の上に表示されている Debug をクリックします:
                        ブレークできることを確認します:
                    すべてのテストを実行できることを確認します:
                        #VSCode Node Debug Console など
                        - cd  "__Project__"
                        - npm test
                    Web アプリケーションのサーバーが動くことを確認します:
                        #VSCode Node Debug Console など
                        - cd  "__Project__"
                        - npm start
                    トラブルシューティング:
                        - ケース:
                            エラー: |
                                The react-scripts package provided by Create React App requires a dependency:
                                "jest": "26.6.0"
                                Don't try to install it manually: your package manager does it automatically.
                                However, a different version of jest was detected higher up in the tree:
                                C:\Users\ts-ne\Desktop\own\node_modules\jest (version: 26.6.1)
                            対策:
                                React が要求している Jest のバージョンに合わせます:
                                    npm install --global  "jest@26.6.0"
                                    npm install  "jest@26.6.0" --save-dev
                        - ケース:
                            エラー: |
                                We detected setupFilesAfterEnv in your package.json.
                                Remove it from Jest configuration, and put the initialization code in src/setupTests.js.
                                This file will be loaded automatically.
                            対策:
                                __Project__/package.json の json キーの中から下記のキーを削除します:
                                    roots, preset, testEnvironment, setupFilesAfterEnv
                                        #// エラーメッセージに削除すべきキーが一覧されます
                プロキシが在る環境 for CentOS7: #keyword: install CentOS7 proxy React VSCode
                    生成済みのプロジェクトを使う場合:  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_create_ts_only
                        プロジェクト(node_modules)を復帰します:  #keyword: resume React CentOS7
                            yarn install --frozen-lockfile  #search: yarn node_modules
                    手動でプロジェクトを生成する場合:
                        VM を作り CentOS7 をインストールします:  #search: install Ansible project
                        VM のメモリーサイズを 2GB に変更します:
                        CentOS に Node.js と yarn をインストールします（IDEなし）:  #search: Node.js CentOS
                        create-react-app をインストールします:
                            失敗するコマンド: npx create-react-app --template typescript  "react1_jest"
                            コマンド: |
                                npm -g config set proxy http://host:port             #template: __Proxy__
                                npm -g config set https-proxy http://host:port       #template: __Proxy__
                                npm -g config set registry http://registry.npmjs.org/
                                npm -g config set strict-ssl=false
                                yarn config set proxy http://host:port -g            #template: __Proxy__
                                yarn config set https-proxy http://host:port -g      #template: __Proxy__

                                npm -g install create-react-app
                                yarn global add react react-dom react-scripts react-scripts-ts
                        React のプロジェクトを生成します:
                            create-react-app --template typescript  "react1ts_jest"  #// 起動まで 2分半かかります
                        （必要なら）プロジェクトをバックアップとしてコピーします:
                        React を使う Web サーバーを起動します:
                            - cd  "react1ts_jest"
                            - yarn start  #// ブラウザーが自動的に開きます
                        コードを変更してすぐに反映されることを確認します:
                            OSに設定されている監視するファイルの最大数を 524288 に変更します:  #search: max_user_watches
                            Web サーバーを再起動します:
                                - Ctrl + C
                                - yarn start
                            表示内容を変更します:
                                src/App.tsx :
                                    変更前: Learn React
                                    変更後: Learn React !
                                #// 保存するとブラウザーに反映されます
                        （試してみたいなら）子コンポーネントを作ります:  #search: React component example
                        React を使う Web サーバーを終了します:
                            - (Ctrl + C で Web サーバーを終了します)
                    参考:
                        Windows企業内プロキシ配下でcreate-react-app（yarnを使う）: #ref: https://qiita.com/otagaisama-1/items/aa559345644e73bb6ac5
                        プロキシがない環境でのインストール: #search: React VSCode
                    トラブルシューティング:
                        - #// ReferenceError: Hook is not defined
                            手順: React の Web サーバーを起動
                            エラー: |
                                ブラウザー内に ReferenceError: Hook is not defined と赤字で表示される
                            対策:
                                React の Web サーバーを再起動します
        コメント:  #search: JSX comment
        コンポーネント, React Hooks:
            基本 >> 子コンポーネントを使います:  #keyword: React component example
                React をインストールします:  #search: install React VSCode
                子コンポーネント MyComponent を作ります:
                    __Project__/src/App.tsx: |
                        import React from 'react';
                        import './App.css';
                        import MyComponent from './MyComponent';  // <--------------- 追加
                        
                        function App() {
                            return (
                                <div className="App">
                                <header className="App-header">
                        
                                    <MyComponent/>            {/* <-------------- <header> の中をこれだけにします */}
                                </header>
                                </div>
                            );
                        }
                        export default App;
                    __Project__/src/MyComponent.tsx: |
                        import React from 'react';

                        export default function  MyComponent() {
                            return (
                                <div>MyComponent</div>
                            );
                        }
                React の Web サーバーを再起動します:  #// ファイルが増えたため
                    Ctrl + C
                    yarn start  または  npm start
            関数コンポーネントと クラス コンポーネント:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#import_JSX
                関数コンポーネント + Hooks:  #keyword: React 関数コンポーネント
                    useState:  #keyword: useState, React onClick  #// 表示に影響する数値や文字列の変数
                        サンプル: | #focus: useState, count, setCount  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_component_hooks/src/2_useState.tsx#useState
                            import React from 'react';

                            // #focus: useState, count, setCount
                            // const  UseState: React.FC = () => {
                            export default function  UseState() {
                                const [count, setCount] = React.useState(0);

                                return (
                                    <div>
                                        2. You clicked {count} times &nbsp;
                                        <button onClick={() => setCount(count + 1)}>
                                            Click me
                                        </button>
                                    </div>
                                );
                            }
                            // export default UseState;  // Besause "export default const" is invalid syntax
                        参考:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_useState
                    React.FC:  #keyword: React.FC, React.FunctionComponent
                        React.FunctionComponent: React.FC のフルネームです
                        サンプル: | #focus: FunctionComponent  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_component_hooks/src/1_FunctionComponent.tsx#React.FC
                            import React from 'react';

                            // #focus: FunctionComponent
                            // const FunctionComponent: React.FC = () => {  // https://stackoverflow.com/questions/36261225/why-is-export-default-const-invalid
                            export default function  FunctionComponent() {
                                return (
                                    <div>1. Function Component</div>
                                );
                            }
                            // export default FunctionComponent;  // Besause "export default const" is invalid syntax
                    プロパティ: #keyword: React property,  React.FunctionComponent property
                        サンプル: | #focus: PropertyProps  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_component_hooks/src/3_property.tsx#PropertyProps
                            import React from 'react';

                            // #focus: PropertyProps
                            let Property: React.FC<PropertyProps>;  export default  Property = (props) => {
                            // export default function  Property(props: PropertyProps) {
                                const [count, setCount] = React.useState(props.count);

                                return (
                                    <div>
                                        3. You clicked {count} times &nbsp;
                                        <button onClick={() => setCount(count + 1)}>
                                            Click me
                                        </button>
                                    </div>
                                );
                            }

                            interface  PropertyProps {
                                count: number;
                            }
                クラス コンポーネント:  #keyword: React クラス コンポーネント
                    サンプル: |
                        class Form<FormFields> extends React.Component<
                            Props<FormFields>,
                            State<FormFields>
                        > {

                            constructor(props: Props<FormFields>) {
                                super(props);
                                this.state = { fields: props.initialValues };
                            }

                            public onChange: OnChangeHandler<FormFields> = (field, value) => {
                                // Use your favorite method to merge objects
                                this.setState({ fields: merge(this.state.fields, { [field]: value }) });
                            };

                            public render() {
                                const { FormComponent } = this.props;
                                const { fields } = this.state;

                                return <FormComponent onChange={this.onChange} fields={fields} />;
                            }
                        }
                    参考: #ref: https://www.mojotech.com/blog/typescript-generic-react-components/ >> A form component
            コンポーネント:  #keyword: React defined components  #// React が提供するコンポーネント、HTML タグ名
                React.StrictMode:  #keyword:  #// ReactDOM.render() に渡すルート要素
                    ReactDOM.render(
                        <React.StrictMode>
                            <App />
                        </React.StrictMode>,
                        document.getElementById('root')
                    );
                React.Fragment:  #keyword: React.Fragment, <>, </>  #// 複数のコンポーネントを返すときのダミー的な ルート タグ
                    サンプル: |
                        import * as React from 'react';
                        <React.Fragment>
                            <div/>
                            <div/>
                        </React.Fragment>
                    サンプル 短縮形: |
                        <>
                            <div/>
                            <div/>
                        </>
                    公式: #ref: https://ja.reactjs.org/docs/fragments.html
            Hooks:  #// React.useRef, React.useHistory
                React.useRef:  #search: React.useRef
                React.useHistory: | #keyword: useHistory,  React URL href  #// URL の変更  #// history.push
                    const Component: React.FunctionComponent<Props> = props => {
                        const history = useHistory();
                        const handleTabChange = (event: React.ChangeEvent<{}>, newValue: string) => {
                            history.push(newValue);
                        };
                React.useLocation: | #keyword:  #// URL
                    const Component: React.FunctionComponent<Props> = props => {
                        const location = useLocation();  // URL
            props:   #keyword: React property,  React.ClassComponent property
                props:  #// 親コンポーネントに書かれた HTML 属性を子コンポーネントに渡します  #focus: props, prop1
                    親コンポーネント:
                        <__ChildComponent__ prop1="aaa"/>
                    子コンポーネント: |
                        export default  __ChildComponent__(props) {
                            return  <div>{props.prop1}</div>;
                        }
                props.children:  #keyword: React props.children  #// 親コンポーネントに書かれた子 HTML 要素を子コンポーネントに渡します  #focus: props.children, __Children__
                    親コンポーネント:
                        <__ChildComponent__><__Children__/></__ChildComponent__>
                    子コンポーネント: |
                        export default  __ChildComponent__(props) {
                            return  <div>{props.children}</div>;  // <div><__Children__/></div>
                        }
                    #// <__Children__/> の部分は <a><b>c</b></a> のようなツリー構造も渡すことができます
                    公式: #ref: https://ja.reactjs.org/docs/composition-vs-inheritance.html#containment
                参考:
                    Snap Note:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#JSX_prop
            HOC, 上位コンポーネント:  #keyword: React HOC,  React 上位コンポーネント  高階コンポーネント  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_HOC
                概要: HigherOrderComponent。 Mix-in ができそうな似たクラスがあるとき、異なる部分をパラメーターにした共通部分の関数が HOC です。
                サンプル:
                    HOC を使う場合:  #// 上位コンポーネントは withSubscription
                        HOC を使う CommentListWithSubscription クラス: |
                            const CommentListWithSubscription = withSubscription(
                            CommentList,
                            (DataSource) => DataSource.getComments()
                            );
                        HOC を使う BlogPostWithSubscription クラス: |
                            const BlogPostWithSubscription = withSubscription(
                            BlogPost,
                            (DataSource, props) => DataSource.getBlogPost(props.id)
                            );
                        HOC: |
                            // This function takes a component...
                            function withSubscription(WrappedComponent, selectData) {
                            // ...and returns another component...
                            return class extends React.Component {
                                constructor(props) {
                                super(props);
                                this.handleChange = this.handleChange.bind(this);
                                this.state = {
                                    data: selectData(DataSource, props)
                                };
                                }
                            
                                componentDidMount() {
                                // ... that takes care of the subscription...
                                DataSource.addChangeListener(this.handleChange);
                                }
                            
                                componentWillUnmount() {
                                DataSource.removeChangeListener(this.handleChange);
                                }
                            
                                handleChange() {
                                this.setState({
                                    data: selectData(DataSource, this.props)
                                });
                                }
                            
                                render() {
                                // ... and renders the wrapped component with the fresh data!
                                // Notice that we pass through any additional props
                                return <WrappedComponent data={this.state.data} {...this.props} />;
                                }
                            };
                            }
                    HOC を使わない場合:  #// this.state と this.setState だけ差分があります
                        HOC を使わない CommentList クラス: |
                            class CommentList extends React.Component {
                            constructor(props) {
                                super(props);
                                this.handleChange = this.handleChange.bind(this);
                                this.state = {
                                comments: DataSource.getComments()
                                };
                            }
                            
                            componentDidMount() {
                                DataSource.addChangeListener(this.handleChange);
                            }
                            
                            componentWillUnmount() {
                                DataSource.removeChangeListener(this.handleChange);
                            }
                            
                            handleChange() {
                                this.setState({
                                comments: DataSource.getComments()
                                });
                            }
                            
                            render() {
                                return (
                                <div>
                                    {this.state.comments.map((comment) => (
                                    <Comment comment={comment} key={comment.id} />
                                    ))}
                                </div>
                                );
                            }
                            }
                        HOC を使わない BlogPost クラス: |
                            class BlogPost extends React.Component {
                            constructor(props) {
                                super(props);
                                this.handleChange = this.handleChange.bind(this);
                                this.state = {
                                blogPost: DataSource.getBlogPost(props.id)
                                };
                            }
                            
                            componentDidMount() {
                                DataSource.addChangeListener(this.handleChange);
                            }
                            
                            componentWillUnmount() {
                                DataSource.removeChangeListener(this.handleChange);
                            }
                            
                            handleChange() {
                                this.setState({
                                blogPost: DataSource.getBlogPost(this.props.id)
                                });
                            }
                            
                            render() {
                                return <TextBlock text={this.state.blogPost} />;
                            }
                            }
            Ref, 子コンポーネントの参照:  #// コードで操作できるようにします
                フック, React.useRef:
                    サンプル プロジェクト:  #// useRef, ref, forwardRef, useImperativeHandle
                        #ref:
                    React.useRef: #keyword:
                        サンプル:  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_useRef/src/2_UseRef.tsx#useRef
                        参考:
                            公式:  #ref: https://ja.reactjs.org/docs/hooks-reference.html#useref
                            Snap Note:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_useRef
                    React.forwardRef: #keyword:
                        サンプル:  #ref: ${GitHub}/MyPrivateCode/react_examples/branch_useRef/src/5_ForwardRef.tsx#forwardRef
                        参考:
                            公式: #// 不明
                            Snap Note:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#forwardRef
                    React.useImperativeHandle: #keyword:  #ref: https://ja.reactjs.org/docs/hooks-reference.html#useimperativehandle
                        サンプル:
                            #ref: ${GitHub}/MyPrivateCode/react_examples/branch_useRef/src/6_UseImperativeHandle.tsx#useImperativeHandle
                            #ref: ${GitHub}/MyPrivateCode/react_examples/branch_useRef/src/7_UseImperativeHandleDeps.tsx#useImperativeHandle
                    React.createRef: #keyword: #ref: https://ja.reactjs.org/docs/refs-and-the-dom.html
                    ref:  #keyword: React ref
                    React.createRef との違い:
                        TypeScriptのもとでuseRefを使うときに知るべきRefObjectとMutableRefObjectについて:
                            #ref: https://zenn.dev/berlysia/articles/624bc1aaffda58
                クラス コンポーネント: #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#React_ref
        HTML プロパティ:
            （HTML タグ名）:  #keyword: React defined components  
            ref:  #search: React ref
        ESLint を無効にする:  #search: disable ESLint
        エラー ハンドリング:  #keyword: React error handling, ErrorBoundary
            参考:
                基本: #ref: https://stackoverflow.com/questions/67319864/react-redirect-to-an-error-page-with-error-message-stack-trace-using-react-rout
                リダイレクト:
                    ErrorBoundary: #ref: https://pretagteam.com/question/how-do-i-redirect-to-error-page-after-receiving-status-404-from-api-call-in-react
        （公開文書）:  #ref: ${GitHub}/Trials/try_Jest_TypeScript_React_VisualStudioCode/steps.yaml#Visual Studio Code
    React Router:  #keyword:  #// URL の変更から、表示するページの変更や、ページの一部の表示を変更します
        手順:  #keyword: install React Router
            React をインストールします:  #search: install React
            React Router をインストールします:  #// プロジェクトにインストールします
                yarn add  react-router-dom  @types/react-router-dom  #// 1分
            子コンポーネントを 2つ作ります:  #search: React component example
                MyComponent.tsx: |
                    import React from 'react';

                    export default function  MyComponent() {
                        return (
                            <div>MyComponent</div>
                        );
                    }
                MyComponent2.tsx: |
                    import React from 'react';

                    export default function  MyComponent2() {
                        return (
                            <div>MyComponent2</div>
                        );
                    }
            ルート要素を置き換えます:
                __Project__/src/index.tsx :  #focus: HashRouter
                    import { HashRouter } from 'react-router-dom';

                    ReactDOM.render(
                        <HashRouter>
                            ____
                        </HashRouter>
                    );
            React Router を設置します:
                __Project__/src/App.tsx : |  #focus: Route
                    import React from 'react';
                    import './App.css';
                    import { Switch, Route } from 'react-router-dom';
                    import MyComponent  from './MyComponent';
                    import MyComponent2 from './MyComponent2';

                    function App() {
                        return (
                            <div className="App">
                                <header className="App-header">

                                    <Switch>
                                        <Route exact path="/"  component={MyComponent}/>
                                        <Route exact path="/2" component={MyComponent2}/>
                                    </Switch>
                                </header>
                            </div>
                        );
                    }

                    export default App;
            React の Web サーバーを再起動します:  #// ファイルが増えたため
                - Ctrl + C
                - yarn start
            ２つの URL で表示されるコンポーネントが異なることを確認します:
                - http://localhost:3000/#/
                - http://localhost:3000/#/2
        ユースケース:
            基本:  #keyword: React Router basic
                サンプル コード: |  #focus: dashboard
                    ...
                            <Link to="/">Home</Link>
                            <Link to="/about">About</Link>
                            <Link to="/dashboard">Dashboard</Link>

                    <div>
                        <Switch>
                            <Route exact path="/" component={Home}/>
                            <Route path="/about" component={About}/>
                            <Route path="/dashboard" component={Dashboard}/>
                        </Switch>
                    </div>
                動き:
                    <Link to="/dashboard">Dashboard</Link> をクリックします:
                    URL が __Domain__/dashboard に変わります:
                    <Switch> の中は、URL にマッチする <Route> だけ表示されます:
                        #// Switch や Route は React コンポーネントです
                参考:
                    #search: React Router Link
                    #search: React Router Switch
                    #search: React Router Route
            URL パラメーター:  #keyword: React Router URL parameters, React Route
                サンプル コード: |  #focus: group, __id__, __ChildComponent__
                    ...
                                <Link to="/group/about">About</Link>
                                <Link to="/group/dashboard">Dashboard</Link>

                    <Route path="/group/:__id__" children={__ChildComponent__} />

                    function __ChildComponent__() {
                        const { __id__ } = useParams();
                動き:
                    <Link to="/dashboard">Dashboard</Link> などをクリックします:
                    URL が __Domain__/dashboard に変わります:
                    path="/:__id__" にマッチします:  #// : はパラメーターであることを表します
                参考:
                    #search: React Router children
                    #search: React Router :
            routes.tsx, 変数への代入:  #// React コンポーネントと同じ扱いです
                サンプル:  #focus: root
                    routes.tsx: |
                        export const  root = (
                            <Switch>
                                <Route path="/____" component={____} />
                                <Route path="/____" component={____} />
                            </Switch>
                        );
                    App.tsx: |
                        import { root } from './routes';

                        function App(props: Props) {
                            return (
                                <div>
                                    {root}
                                </div>
                            );
                        }
                サイトマップ的に 1つのファイルにまとめます:
                    routes.tsx: |
                        export const  root = (
                            <Switch>
                                <Route path="/group1"  component="Group1" />
                                <Route path="/group2"  component="Group2" />
                            </Switch>
                        );

                        export const  group1 = (
                            <Switch>
                                <Route path="/____" component={____} />
                                <Route path="/____" component={____} />
                            </Switch>
                        );

                        export const  group2 = (
                            <Switch>
                                <Route path="/____" component={____} />
                                <Route path="/____" component={____} />
                            </Switch>
                        );
                    Group1.tsx: |
                        function Group1() {
                            return (
                                <div>
                                    {group1}
                                </div>
                            );
                        }
                    Group2.tsx: |
                        function Group1() {
                            return (
                                <div>
                                    {group2}
                                </div>
                            );
                        }
            その他:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#ReactRouter
        コンポーネント:  #// ReactRouter のコンポーネント
            ReactRouter 名前空間:  #keyword: ReactRouter tag
                タグ名を <ReactRouter.Route> などで指定する場合: |
                    import * as ReactRouter from 'react-router-dom';
                    const  child = (
                        <ReactRouter.Switch>
                            <ReactRouter.Route path="/____"> ____ </ReactRouter.Route>
                            <ReactRouter.Route path="/____"> ____ </ReactRouter.Route>
                        </ReactRouter.Switch>
                    );
                タグ名を <Route> などで指定する場合: |
                    import { Switch, Route } from "react-router-dom";
                    const  child = (
                        <Switch>
                            <Route path="/____"> ____ </Route>
                            <Route path="/____"> ____ </Route>
                        </Switch>
                    );
            Link: #keyword: React Router Link  #// クリックする場所に配置します
                参考:
                    Material-UI の Tab に React Router を使います:  #search: Material-UI Tab Router
            Switch: #keyword: React Router Switch  #// Route コンポーネントなどの親コンポーネントの位置に配置します
                サンプル:  #search: React Router basic
                    <Switch>
                        <Route path="/____" component={____} />
                        <Route path="/____" component={____} />
                    </Switch>
            Route など Switch の子要素:  #// Route, Redirect
                Route:  #keyword: React Router Route  #// URL によって表示または非表示になるコンポーネント
                    関連 >> タグ名を <ReactRouter.Route> などで指定する場合:  #search: ReactRouter tag
                    基本サンプル, component:  #keyword: React Router component
                        <Switch>
                            <Route path="/____" component={____} />
                            <Route path="/____" component={____} />
                        </Switch>
                    exact:  #// URL の全体一致  #focus: exact  #keyword: React Router exact
                        <Route exact path="/" component={____} />
                        #// exact がないと前方一致になり、URL が /about などでもマッチします
                    コンポーネント以外のとき:  #// component 属性を削除します
                        修正前: <Route path="/____" component={__Conponent__} />
                        修正後: <Route path="/____"> <__Tag__> ____ </__Tag__> </Route>
                    children:  #// URL パラメーターを受ける子コンポーネント  #keyword: React Router children
                        <Route path="/group/:__id__" children={__ChildComponent__} />
                        #search: React Router URL parameters
                    条件分岐:
                        有無: |  #focus: &&
                            {condition &&
                                <Route path="/____" component={____} />
                            }
                        切り替え: |  #focus: ?, :
                            {condition ?
                                <Route path="/____" component={____} />
                            :
                                <Route path="/____" component={____} />
                            }
                    Not Found (404):  #// 最後の Route に exact path="/*"
                        <Route exact path="/*" render={() => 'Not found.'} />
                Redirect:  #keyword: React Router Redirect  #// URL をリダイレクトする設定
                    <Redirect to="/new" from="/old" />
                        #// /old にアクセスすると /new にリダイレクトされます。ブラウザーの URL も /new に変わります
            ルート要素: #// HashRouter, BrouserRouter
                HashRouter:     #keyword: React Router HashRouter  #// URL のドメイン名の直後に # を入れる場合、ルートに配置します
                    import { HashRouter } from 'react-router-dom';

                    ReactDOM.render(
                        <HashRouter>
                            ____
                        </HashRouter>
                    );
                BrouserRouter:  #keyword: React Router BrouserRouter  #// URL のドメイン名の直後に # を入れない場合、ルートに配置します
                    ReactDOM.render(
                        <BrouserRouter>
                            ____
                        </BrouserRouter>
                    );
                StaticRouter:   #keyword: React Router StaticRouter  #// サーバーサイド レンダリング の場合、ルートに配置します
            内部定義コンポーネント:  #// Router.Cosumer, Router.Provider  #// React Router が自動的に作る内部コンポーネント
                Router.Provider, Router.Cosumer:  #keyword:
                    概要: React Developer Tools で見ることができますが、コードには現れません
                    サンプル:
                        ...
                        <Switch>
                            <Router.Cosumer>                                       ← 内部定義
                                <Route path="/____" component={__Component__} />
                                    <Router.Cosumer>                               ← 内部定義
                                        <Router.Provider>                          ← 内部定義
                                            <Container>                            ← 内部定義
                                                <__Component__>
        Snap Note:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#ReactRouter
        公開部分:  #ref: ${GitHub}/Trials/try_Jest_TypeScript_React_VisualStudioCode/steps.yaml#React Router
    Redux:  #keyword:
        公開部分:  #ref: ${GitHub}/Trials/try_Jest_TypeScript_React_VisualStudioCode/steps.yaml#Redux
    JSX, TSX:  #keyword: #// JavsScript と HTML を融合したソース  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#JSX
        コメント:  #keyword: JSX comment
            JavaScript 部分:
                // comment
            HTML タグ外: |
                {/* __Comment__ */}
                { // __Comment__
                }
            HTML タグ内: |
                <img  // __Comment__
                />
    デバッグ >> React Developer Tools:  #keyword:  #ref: ${programming}/スクリプト/JavaScrpt/JavaScript.svg#ReactDeveloperTools
        インストール:
            Chrome, Edge: https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=ja
        ツールが使えるページ:
            公式: #ref:  https://ja.reactjs.org/docs/optimizing-performance.html
            ツールが使えるページかどうかを確認します:
                メニュー: ブラウザー >> React Developer Tools のアイコン
                赤い背景のアイコンのとき: フル機能が使えるページです
                黒い背景のアイコンのとき: #// 一部の機能が使えないページです
                    できること:
                        コンポーネントを探します:
                            Edge >> F12 キー >> Components（タブ）>> Select an element in the page to inspect it ボタン（左上）
                            #search: React Developer Tools GUI source
                    できないこと:
                        source プロパティを表示します:
                            #search: React Developer Tools GUI source
        コンポーネントのツリーを表示します:  #// HTML のツリーは表示されません
            Edge >> F12キー >> 要素（タブの左の矢印ボタン） >> （HTML 要素をクリック） >> Components タブ
        UI部品に対応するコードの場所を探します (React Developer Tools):
            開発環境で React が表示される Web サーバーを起動します:  #// ビルドした後の Web サーバーではコードが書かれているパスは分かりません
            React Developer Tools で対象のコンポーネントの source プロパティを表示します:  #keyword: React Developer Tools GUI source
                Edge >> F12 キー >> Components（タブ）>> Select an element in the page to inspect it ボタン（左上）>>
                （対象の GUI 部品をクリック）>>（フォーカスされたツリーの項目をクリック）>>
                source のグループ（右下）が表示されるまで左カーソルキーを押して親方向にたどります
                #// source が全く存在しない場合、webpack-dev-server で React を起動すると source は表示されないようです
            コピーする場合:  #// 対象のコンポーネントのコードが書かれているフルパスと行番号をクリップボードにコピーします
                Copy to clipboard ボタン（source の右上）
            表示する場合:  #// ソース コード をブラウザーに表示します
                < > ボタン（右半分のビューの右上、クラスのコードが表示されます）
        useState フックまたは props の値を変更します:
            useState を呼び出しているコンポーネントを探します:
                Edge >> F12 キー >> Components（タブ）>> Select an element in the page to inspect it ボタン（左上）>>
                （対象の GUI 部品をクリック）>>（フォーカスされたツリーの項目をクリック）>>
                hooks または props のグループ（右）が表示されるまで左カーソルキーを押して親方向にたどります
            useState の返り値を格納している変数の名前を表示します:
                Parse hook names ボタン（魔法のステッキ：hooks の右上）
            対象の hooks または props 値を変更します:
                値をクリック >> 値を入力 >> Enter キー
        ブレークポイントを張ります:  #keyword: React break point debug
            ソース ファイルのパスが分かっている場合:
                #// React Developer Tools は不要
                対象のソース ファイルを表示します:
                    Edge >> F12キー >> Source タブ >> Ctrl + P (Open File)（全部閉じたときに Ctrl + P であることが表示されます）>>
                        （ソース ファイルがあるマシーンの中でのフルパスを入力します）（コピペします）>>
                        （すぐ下に表示された候補をクリックします）
                    #// フルパスで見つからないときは、ファイル名やパスの後半だけ入力します
                ブレークポイントを張る行番号の左をクリックします:
            例外が発生した場所でブレークさせる場合:
                例外で一時停止する ボタン（ステップ実行などのボタンの並びの最も右）
            GUI から探す場合:
                React Developer Tools をインストールします:
                対象のソース ファイルを表示します:  #search: React Developer Tools GUI source
                ブレークポイントを張る行番号の左をクリックします:
        関連 >> Chrome 開発者ツール:  #search: Chrome developer tools
        トラブルシューティング:
            - #// ほとんどのコンポーネントが Anonymous と表示される
                手順: 
                エラー: ほとんどのコンポーネントが Anonymous と表示される
                対策:
                    ビルドした React プロジェクトでは Anonymous と表示されるようです。
                    開発環境で実行してください。
ESLint:  #keyword: ESLint
    参考: https://eslint.org/
    ESLint を無効にする:  #keyword: disable ESLint
            package.json: |
                {
                    "eslintConfig": {
                        "ignorePatterns": ["src/*", "!src/test.js"],
    ESLint の警告のルールの制御:
        参考: https://eslint.org/docs/user-guide/configuring/rules
        サンプル: |
            /* eslint eqeqeq: "off" */
        ルール:
            eqeqeq:
                内容: ==, != は NG、===, !== は OK。
                サンプル: |
                    /* eslint eqeqeq: ["off", "smart"] */
                smart（設定値）:
                    null との比較は == で OK（undefined でも true にするため）など
                    https://eslint.org/docs/rules/eqeqeq#smart
            その他: https://eslint.org/docs/rules/
        設定値: [ "off", "warn", "error" ]
        プロジェクト全体に対する警告の制御:
            注意: React の場合、設定を変更したら、サーバーの再起動が必要です
            package.json: |
                {
                    "eslintConfig": {
                        "rules": {
                            "eqeqeq": "off",
        １つのファイル全体に対する警告の制御:
            ファイルのどこかに下記のようなコメントを書きます:
                eqeqeq ルールを警告しない: |
                    /* eslint eqeqeq: "off" */
                eqeqeq ルールを警告、curly ルールをエラーにします: |
                    /* eslint eqeqeq: "warn", curly: "error" */
lodash:  #// 基本的なユーティリティ。最新 JavaScript の基本機能と重複しているものが多い  #keyword: lodash
    参考:
        基本: #ref: https://qiita.com/sonishimura/items/a08e28def541c28458a0
        lodash やめ方: #ref: https://qiita.com/mizchi/items/af17f45d5653b76f6751
Storybook:  #keyword: Storybook
    Storybook + React + TypeScript の環境構築:
        参考:
            - Storybook V5+React+TypeScriptで環境構築(古い情報): https://qiita.com/otanu/items/dd06d6702f673268c74e
            - 公式変更履歴: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#source-loader
        設定: #settings:
            __Project__: taskbox-ts
        Storybook をインストールします:
            #Git bash
            - cd  "__ParentOfProject__"
            - npx create-react-app "taskbox-ts" --typescript  #template: "__Project__"
            - cd "taskbox-ts"  #template: "__Project__"
            - yarn add --dev @storybook/cli
            - yarn sb init
        コンポーネント エクスプローラー(Storybook)を起動します（しなくてもよい）:
            #Git bash
            - cd  "__Project__"
            - yarn storybook
            - 自動的にブラウザー内で コンポーネント エクスプローラーが起動します
            - コンポーネント エクスプローラー（ブラウザーのタブ）を閉じます
            - シェルで Ctrl + C を押して「コンポーネント エクスプローラー」を終了します
        TypeScript に対応させ、推奨のアドオンを追加します:
            yarn add を実行します: |
                #Git bash
                cd  "__Project__"
                yarn add --dev @storybook/addon-knobs \
                    @storybook/addon-viewport \
                    @storybook/addon-storysource \
                    babel-loader@8.1.0 \
                    typescript \
                    react-docgen-typescript-loader \
                    @types/storybook__react \
                    @storybook/source-loader \
                    @storybook/addon-info \
                    @storybook/addon-console \
                    @types/storybook__addon-info \
                    @types/storybook__addon-actions \
                    @types/storybook__addon-knobs
            __Project__/.storybook/addons.js ファイルを新規作成します: |
                import '@storybook/addon-actions/register';
                import '@storybook/addon-links/register';
                import '@storybook/addon-knobs/register';
                import '@storybook/addon-viewport/register';
                import '@storybook/addon-storysource/register';
                import '@storybook/addon-console';
            __Project__/.storybook/webpack.config.js ファイルを新規作成します: |
                const path = require("path");

                // TypeScriptのソースをアドインに渡します
                module.exports = ({ config }) => {
                    config.module.rules.push({
                        test: /\.(ts|tsx)$/,
                        use: [
                        {
                            loader: require.resolve("react-docgen-typescript-loader")
                        },
                        {
                            loader: require.resolve('@storybook/source-loader'),
                            options: { parser: 'typescript' }
                        }
                        ]
                    });
                    config.resolve.extensions.push(".ts", ".tsx");
                    return config;
                };
            __Project__/.storybook/preview.js ファイルに下記を追加します: |
                import { configure } from '@storybook/react';
                import { setConsoleOptions } from '@storybook/addon-console';

                // コンソールログをActionsタブに表示します
                setConsoleOptions({
                    panelExclude: []
                });

                // TypeScriptで作成したストーリーを読み込みます
                function loadStories() {
                    let req = require.context("../src/stories", true, /.(tsx|js)$/);
                    req.keys().forEach(filename => req(filename));

                    req = require.context("../src", true, /.stories.(tsx|js)$/);
                    req.keys().forEach(filename => req(filename));
                }

                configure(loadStories, module);
        サンプルのコンポーネントを追加します:
            __Project__/src/components/Example/index.tsx にサンプルのコンポーネントを新規作成します: |
                import React, { useState, useCallback } from "react";

                export interface ExampleProps {
                    /** 表示するテキスト */
                    text: string;
                    /**
                    * true: テキスト表示 false: テキスト非表示
                    * @default false
                    */
                    flag?: boolean;
                    /** ボタンを押した時のイベントハンドラ */
                    action(): void;
                }

                const Example = (props: ExampleProps) => {
                    const { text, flag, action } = props;
                    const [count, countChg] = useState(0);
                    const countUp = useCallback(() => countChg(prev => prev + 1), []);
                    const countDown = useCallback(() => countChg(prev => prev - 1), []);

                    return (
                        <div>
                            {flag && <p>{text}</p>}
                            <button onClick={action}>ボタン</button>
                            <p>count:{count}</p>
                            <button onClick={countUp}>+</button>
                            <button onClick={countDown}>-</button>
                        </div>
                    );
                };

                export default Example;
            __Project__/src/components/Example/index.stories.tsx にストーリーを新規作成します: |
                import React from "react";

                import { storiesOf } from "@storybook/react";
                import { withKnobs, text, boolean } from "@storybook/addon-knobs";
                import { action } from "@storybook/addon-actions";

                import Example from "../Example";

                const components = storiesOf("Components", module);
                components
                    .addDecorator(withKnobs)
                    .add("Example", () => (
                        <Example
                            text={text("テキスト", "ああああ")}
                            flag={boolean("テキスト表示", true)}
                            action={action("ぽちっとな")}
                        />
                    ));
        コンポーネント エクスプローラー(Storybook)を起動します:
            #新しい Git bash
            - cd  "__Project__"
            - yarn storybook  #// 1回目約 2分、2回目約 1分半
            #// Conponents（左）の中にサンプルのコンポーネント Example があることを確認します
            #// コンポーネント エクスプローラー（ブラウザーのタブ）を閉じます
            #// シェルで Ctrl + C を押して コンポーネント エクスプローラー を終了します
        React アプリケーションを起動できることを確認します:
            #新しい Git bash
            - cd  "__Project__"
            - yarn start
            #// アプリケーションは React の初期状態 です
            #// エラーにならないことを確認します
            #// React アプリケーション（ブラウザーのタブ）を閉じます
            #// シェルで Ctrl + C を押して React アプリケーションを終了します
        テスト モード（Jest）が使えることを確認します:
            #新しい Git bash
            - cd  "__Project__"
            - yarn test --watchAll
            #// Tests:  __ passed, __ total と表示されることを確認します
    React 向け Storybook のチュートリアル:
        参考:
            - 公式: https://www.learnstorybook.com/intro-to-storybook/react/ja/get-started/
            - ReactでStorybook チュートリアルをやってみました。: https://qiita.com/fufujimoto/items/112fafc332df8bf3a55d
        準備:
            上記「Storybook + React + TypeScript の環境構築」を行います
Atomic Design:  #keyword:  #glossary: Atomic Design  #ref: https://bradfrost.com/blog/post/atomic-web-design/
    #keyword: Atoms, Molecules, Organisms, Templates, Pages  #ref: ${programming}/ユーザインターフェイス/使い勝手.svg#AtomicDesign
    Atoms: #// 原子
    #// Atoms: 単独コンポーネント, Molecules: 複数組合せコンポーネント
    Molecules: #// 分子, 「モレキュール」, Atoms を組み合わせて作る部品。ほとんどない
    #// Molecules: ～が変わる, Organisms: 組み合わせによって意味/意図が変わらない
    Organisms:  #// 有機体, 「オーガニズム」（エッチなオーガズムではないw）,  ほとんどの部品はこれ
    #// Organisms: ～ができない, Templates: 配置を自由に変えることができる
    Templates:
    #// Templates: ～に依存しない, Pages: 実際のデータに依存する
    Pages:  
    参考:
        Atomic Design と、弊チームで扱うためのカスタマイズについて: #ref: https://qiita.com/putan/items/ec312314698087fca5b2
用語: #glossary:
    client side navigation: JavaScript でページが変わったように見せること。リンク先の HTML をロードしないため高速
    SPA: Single Page Application。複数のページをまとめることで、動作が素早くなったホームページ
    SSR: #search: サーバーサイド レンダリング
    SSG: Static Site Generation。ビルド時にレンダリングすることで、ダウンロードを早くしたホームページ
トラブルシューティング:
    console.log が表示されない:
        Node.js:
            Visual Studio Code に表示されます
        React:
            ブラウザーのコンソールに表示されます
    throughCounter:
        #search: cc
    React Developer Tools:  #search: React Developer Tools
    デバッガーがブレークした後、勝手に終了する:
        #search: Node.js child_process.exec timeout
    ファイルを削除できなくなる:  #// test_data/_checking を削除できなくなる fs.rmdirSync
        -   Windows で、正しくアクセスしなかったファイルを含むフォルダーを fs.rmdirSync
            すると、エクスプローラーからそのフォルダーの中に入れなくなります。
        -   処理しない範囲を狭めるときは、break や return ではなく /* */ で狭めてください。
            Node.js が許さないため
        -   Node.js の createReadStream の行のループで例外が発生するなどして全ての行をリードしないと不正なアクセスになります。
            #serach: exampleReadStream
    エラーメッセージ:
        - #// CORS エラー
            エラー: |
                Access to fetch at '__TargetURL__' from origin '__CallerURL__' has been blocked
                by CORS policy: No 'Access-Control-Allow-Origin' header is present
                on the requested resource. If an opaque response serves your needs,
                set the request's mode to 'no-cors' to fetch the resource with CORS disabled.
            対策:
                express サーバーを CORS に対応する:
                    #search: express CORS
                no-cors を指定する場合:
                    注意: エラーではなくなりますが、データを取得できないので注意してください。
                    コード: |  #focus: no-cors, text
                        fetch('__TargetURL__', {mode: 'no-cors'})
                            .then(response => {
                                console.log(response);
                                response.text().then((text)=>{
                                    console.log(text);
                                });
                            });
        - #// esModuleInterop
            手順: VSCode 静的チェック
            エラー: |
                Module '"____"' can only be default-imported using the 'esModuleInterop' flagts(1259)
            対策:
                tsconfig.json : |
                    {
                        "compilerOptions": {
                            "esModuleInterop": true,
        - #// allowSyntheticDefaultImports
            手順: VSCode 静的チェック
            エラー: |
                This module can only be referenced with ECMAScript imports/exports by turning on the
                'allowSyntheticDefaultImports' flag and referencing its default export.ts(2497)
            対策:
                tsconfig.json : |  #keyword: allowSyntheticDefaultImports
                    {
                        "compilerOptions": {
                            "allowSyntheticDefaultImports": true,
        - #// Cannot find module 'node:url'
            手順: ビルド時
            エラー: |
                import {URL} from 'node:url';
                Cannot find module 'node:url' or its corresponding type declarations.ts(2307)
            対策:
                globby の場合:
                    バージョンを 11 に戻します
        - #// Cannot find module '____.cjs'  #keyword: import .cjs error
            手順: テキスト エディター で編集しているとき
            エラー: |
                Cannot find module '____.cjs' or its corresponding type declarations. ts(2307)
            対策:
                // @ts-ignore
                import ____ from './____.cjs';
            (@ts-ignore): #keyword:
                概要: 次の行の警告を無視します
                #// tsconfig.json の allowJs を true にしても .cjs はコンパイルされません
        - #// File '____/lib-cjs.js' not found. Matched by include pattern '**/*'
            手順: Node.js のプロセスを起動したとき
            エラー: |
                File '____/lib-cjs.js' not found.
                The file is in the program because:
                    Matched by include pattern '**/*' in '__Project__/tsconfig.json'
                File not found. The file is in the program because Matched by include pattern '**/*'
            対策:
                ファイルの拡張子 .cjs を .js に変更します
        - #// '____.ts' is not a module. ts(2306)
            手順: テキスト エディター で編集しているとき
            エラー: |
                File '__Project__/src/__snapshots__/main.test.ts.snap.ts' is not a module. ts(2306)
            対策:
                ____.d.ts ファイルを作り、export します  #search: .d.ts
        - #// ReferenceError: __dirname is not defined in ES module scope
            手順: Node.js のプロセスを起動したとき
            エラー: |
                ReferenceError: __dirname is not defined in ES module scope
            対策:
                import * as url from 'url';
                import * as path from 'path';
                const __filename = url.fileURLToPath(import.meta.url);
                const __dirname = path.dirname(__filename);
                #ref: https://stackoverflow.com/questions/64383909/dirname-is-not-defined-in-node-14-version
        - #// ReferenceError: require is not defined in ES module scope, you can use import instead
            手順: Node.js のプロセスを起動したとき
            エラー: |
                ReferenceError: require is not defined in ES module scope, you can use import instead
                This file is being treated as an ES module
                because it has a '.js' file extension and '__PackageJSON__' contains "type": "module".
                To treat it as a CommonJS script, rename it to use the '.cjs' file extension.
            対策: #// 以下のいずれか
                - ES module の中では require は使えません。import を使ってください。
                    #search: ES modules
                - 拡張子を .cjs に変更して CommonJS とし、require をお使いください。
                    #search: import .snap
        - #// Uncaught Error [ERR_MODULE_NOT_FOUND]: Cannot find module '__TargetPath__' imported from __SourcePath__
            手順: Node.js のプロセスを起動したとき
            エラー: |
                Uncaught Error [ERR_MODULE_NOT_FOUND]: Cannot find module '__TargetPath__' imported from __SourcePath__
            対策:
                import 文に拡張子を書いていないとき:  #keyword: JavaScript import extension
                    import 文の例: import * as lib from "./lib";  #// ./lib.ts ファイルや　./lib.js ファイルはある
                    対策:
                        node コマンドを使って起動するとき:  #// --experimental-modules --experimental-specifier-resolution オプションを使います
                            node --experimental-modules --es-module-specifier-resolution=node  build/app.js
                        VSCode の JavaScript Debug Terminal で npm test を起動するとき:
                            tsconfig.json: |
                                {
                                    "compilerOptions": {
                                        "moduleResolution": "node"
                    ES2015 での対策, ES2020 では非推奨の対策:
                        .ts ファイルに書く import 文に ____.ts の代わりに ____.js を指定します:
                            import ____ from '___.js';
                            #// node コマンドを使って起動するときは動作しますが、TypeScript の開発環境ではエラーになります
                    参考:
                        Node.js v12のES Modulesと、Babel/TypeScriptの対応について:
                            #ref: https://qiita.com/shimataro999/items/8a63ec06f33ccd2ea9ca
                        ES modules では、ファイル拡張子の自動解決は行われません。:
                            #ref: https://stackoverflow.com/questions/63459159/omit-the-file-extension-es6-module-nodejs
                            #ref: https://stackoverflow.com/questions/51452743/importing-using-relative-paths-in-node-js-with-es-modules
                        最近のTypeScriptのES Modules対応事情: #ref: https://blog.zelkova.cc/2021/10/typescript-esmodules.html
        - #// error TS18003: Build:No inputs were found in config file '____/tsconfig.json'. Specified 'include' paths were '["**/*"]' and 'exclude' paths were '____'.
            手順: VSCode を開いたとき
            エラー:
                tsconfig.json ファイルの先頭: |
                    error TS18003: Build:No inputs were found in config file '____/tsconfig.json'. Specified 'include' paths were '["**/*"]' and 'exclude' paths were '____'.
            対策:
                VSCode を再起動します
        - #// FATAL ERROR: invalid array length Allocation failed - JavaScript heap out of memory
            手順: テキスト エディター で編集しているとき
            エラー: |
                FATAL ERROR: invalid array length Allocation failed - JavaScript heap out of memory
            対策:
                無限ループや無限再帰しないようにコーディングします
        - #// json_parse_exception Invalid UTF-8 start byte
            手順: Java による JSON パース。 Ascii 文字以外の文字を含む JSON データをシェルから指定  #keyword: shell JSON Invalid UTF-8
            エラー: |
                {"error":{"root_cause":[{"type":"json_parse_exception","reason":"Invalid UTF-8 start byte 0x8d\n
                at [Source: (org.elasticsearch.common.io.stream.InputStreamStreamInput); line: 2, column: 41]"}]
            対策:
                kuromoji プラグインをインストールしてください:  #search: kuromoji
                JSON データを UTF-8 形式でファイルに書き、コマンドにファイル名を指定します: |
                    curl -X  GET  http://localhost:9200/museum/_search  -H "Content-Type: application/json" --data-binary @sample_query.json
            メモ:
                成功します: |
                    curl -X  GET  http://localhost:9200/museum/_search  -H "Content-Type: application/json" -d '{
                        "query": {"match_phrase": { "city_id": "13101" } }
                    }'
                失敗します: |
                    curl -X  GET  http://localhost:9200/museum/_search  -H "Content-Type: application/json" -d '{
                        "query": {"match_phrase": { "name": "国立" } } 
                    }'
        - #// The 'arguments' object cannot be referenced
            手順: arguments に対する警告  #search: js arguments
            エラー: |
                The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5.
                Consider using a standard function expression.
            対策:
                処置前:
                    () => { argurments }
                処置後:
                    function () { argurments }
        - #// ECMAScript 5 and higher.
            手順: TypeScript の文法エラー
            エラー: |
                Accessors are only available when targeting ECMAScript 5 and higher.ts(1056)
                https://stackoverflow.com/questions/41010780/accessors-are-only-available-when-targeting-ecmascript-5-and-higher
            対策:
                __Project__/tsconfig.json: |
                    {
                        "compilerOptions": {
                            "target": "es5",
        - #// Must use import to load ES Module
            ケース: node のスクリプトを起動
            Error: |
                Error [ERR_REQUIRE_ESM]: Must use import to load ES Module:
            対処法A: node_modules を作り直してください
            対処法B:
                indent-string:
                    node_modules/indent-string/package.json :
                        変更前: |
                            "type": "module"
                        変更後: |
                            "type": "commonjs"
                    node_modules/indent-string/index.js :
                        変更前: |
                            export default function indentString
                        変更後: |
                            module.exports.default = function indentString
        - #// Error: EISDIR: illegal operation on a directory
            ケース: VSCode に Jest 拡張機能を追加
            Error: |
                Error: EISDIR: illegal operation on a directory, realpath '__Path__'
            対処法: プロジェクトを RAM ディスクの外に移動します
            メモ: RAM ディスク imdisk は使うべきではないらしい
            参考: https://github.com/nodejs/node/issues/6861
        - #// Jest file 0 matches
            ケース: VSCode に Jest 拡張機能を追加した環境で、コード中に追加された Debug ボタンを押した
            Error: |
                testMatch: **/__tests__/**/*.+(ts|tsx|js), **/?(*.)+(spec|test).+(ts|tsx|js) - 0 matches
            対処法: テストのファイル名を *.test.ts などに修正してください。
                成功したテストの上の Debug ボタンは消えますが、テストに失敗すると Debug ボタンが現れます。
        - #// TypeScript emitted no output for ____.tsx
            エラー: TypeScript emitted no output for ____.tsx
                .js ファイルなどを出力できなかった
            原因: |
                tsconfig.jsonで["noEmit": true]と記載していると、発生します。
                noEmitとは、ファイルを出力しないようにするための設定で、TypeScriptからもファイルを出力する場合、削除します。
            対処法A:
                tsconfig.json の noEmit を 削除します。
            対処法B: |
                tsconfig.jsonで["noEmitOnError": true] を設定している場合、他のエラーを直すと、このエラーが直りそうです
            参考:
                - https://thomasjs8.hatenablog.com/entry/2019/09/13/010457
                - https://stackoverflow.com/questions/55304436/webpack-with-typescript-getting-typescript-emitted-no-output-error/55304691
        - #// can only be directly nested in external modules or ...
            エラー: Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.
            対策: グローバル スコープの拡張は、外部モジュールまたはアンビエント モジュール宣言内でのみ直接入れ子にすることができます。
            修正前: |
                declare global {
            修正後: |
                export {};
                declare global {
            参考: https://stackoverflow.com/questions/57132428/augmentations-for-the-global-scope-can-only-be-directly-nested-in-external-modul
        - #// Type 'Map<number, string>' is not an array type or a string type. Use compiler option '--downlevelIteration' to allow iterating of iterators.ts(2569)
            手順: |  #// new Map の中の map1, map2 にコーディング時エラー
                const  map1 = new Map<number, string>([[1, 'A'],  [3, 'B']]);
                const  map2 = new Map<number, string>([[3, 'BB'], [7, 'C']]);
                var merged = new Map([...map1, ...map2]);
            エラー: |
                Type 'Map<number, string>' is not an array type or a string type. Use compiler option '--downlevelIteration' to allow iterating of iterators.ts(2569)
            対策:
                tsconfig.json: |
                    {
                        "compilerOptions": {
                            "target": "es2015",
                            "module": "es2015",
                            "lib": [ "es2015" ],
